<!DOCTYPE HTML>
<html lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Recomedia Visu- &amp; Web-Logikbausteine - Hilfe - Formelberechnung</title>
  <link rel="StyleSheet" href="default.css" type="text/css" />
</head>

<body>
  <header>
    <span id="headBlack">Recomedia Visu- &amp; Web-Logikbausteine</span>
    <span id="headGray">Hilfe</span>
  </header>
  <section>
    <div class="contentholder">
      <div class="navlinks-top">
        <a href="#footerHead">↓ Andere Logikbausteine in diesem Paket</a>
        &nbsp; | &nbsp; <a href="Index.html">← Paketinhalt</a>
      </div>
      <h1>
        <img src="../icons/ExpressionCalculatorNode.png" alt="" />&nbsp;
        Formelberechnung
      </h1>
      <h2>Inhaltsverzeichnis</h2>
      <img src="ExpressionCalculator.png" alt="" class="description" />
      <ul>
        <li><b><a href="#beschreibung">Beschreibung</a></b></li>
        <li><b><a href="#eingaenge">Eingänge</a></b></li>
        <li><b><a href="#ausgaenge">Ausgänge</a></b></li>
        <li><b><a href="#parameter">Parameter</a></b></li>
        <li><b><a href="#platzhalter">Platzhalter für Variablen</a></b></li>
        <li><b><a href="#eingangsvariablen">Welche Eingangswerte sind neu?</a></b></li>
        <li><b><a href="#ausgangsvariablen">Ausgangswerte als Variablen</a></b></li>
        <li><b><a href="#konstanten">Literale Konstanten</a></b></li>
        <li><b><a href="#operatoren">Operatoren</a></b></li>
        <li>
          <b><a href="#funktionen">Funktionen</a></b><br />
          <a href="#math">Mathematische Funktionen</a> &ndash;
          <a href="#string">Textbearbeitung</a> &ndash;
          <a href="#light">Beleuchtungssteuerung</a> &ndash;
          <a href="#HLK">Heizungs-, Lüftungs- und Klimatechnik (HLK)</a>
        </li>
        <li><b><a href="#kommentare">Kommentare</a></b></li>
        <li>
          <b><a href="#beispiele">Beispiele</a></b><br />
          <a href="#feiertag">Feiertage</a> &ndash;
          <a href="#zeitstempel">UNIX-UTC-Zeitstempel umwandeln</a> &ndash;
          <a href="#hysterese">Verbesserter Schwellwert mit Hysterese</a> &ndash;
          <a href="#summenzaehler">Summenzähler</a> &ndash;
          <a href="#zustandsautomat">Zustandsautomat</a>
        </li>
      </ul>
      <h2 id="beschreibung">Beschreibung</h2>
      <p>
        Dieser Baustein errechnet aus einer oder mehreren mathematischen Formeln
        entsprechende Ausgabewerte. Die Formeln sind frei festlegbar. Sie können
        aus Konstanten, Platzhaltern für variable Eingangswerte, Rechenoperationen,
        Funktionsaufrufen und Kommentaren bestehen. Die Platzhalter bestimmen Anzahl,
        Namen und Porttypen der Eingänge.
      </p>
      <p>
        Folgende Arten von Eingangs- und Ausgabewerten können verarbeitet werden:
      </p>
      <ul>
        <li>
          Wahrheitswerte (<code>bool</code>)
        </li>
        <li>
          Numerische Werte (Ganzzahlen <code>byte</code>, <code>int</code>, <code>long</code> und
          Fließkommazahlen <span class="manhyphens"><code>double</code></span>)
        </li>
        <li>
          Texte (<code>string</code>)
        </li>
      </ul>
      <p>
        In den Formeln können die üblichen
        <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/">Rechenoperationen (der Programmiersprache C#)</a>
        verwendet werden. Darüber hinaus stehen auch viele nützliche Methoden des
        <a href="https://docs.microsoft.com/de-de/dotnet/api/?view=netframework-4.0">.NET 4.0 API</a>s
        zur Verfügung.
      </p>
      <h3>Implementierung und Lizenzen</h3>
      <p>
        Dieser Baustein würde eigentlich thematisch besser ins Paket "Recomedia
        Generische Logikbausteine" passen. Aus technischen Gründen &ndash; er
        nutzt dieselbe Platzhalter-Implementierung wie der
        <a href="StringFormatter.html">Textformatierer</a>
        &ndash; muss er aber in diesem Paket ausgeliefert werden.
      </p>
      <p>
        Die Implementierung verwendet den
        <a href="http://docs.go-mono.com/?link=M%3aMono.CSharp.Evaluator.Evaluate(System.String)">Mono.CSharp.Evaluator</a>-Service (Version 3.6.1). Dieser steht
        <a href="https://www.mono-project.com/docs/faq/licensing/">unter der MIT-Lizenz</a>
        kostenlos
        <a href="https://github.com/mono/mono/blob/master/mcs/mcs/eval.cs">mit Quelltext</a>
        zur Verfügung.
      </p>
      <h2 id="eingaenge">Eingänge</h2>
      <p>
        Solange keine gültige(n) <a href="#parameter">Formel</a>(n) festgelegt
        wurde(n), hat der Baustein keine Eingänge.
        <i><b>Eingänge werden nur durch gültige Platzhalter in den Formeln angelegt.</b></i>
        Die Reihenfolge der Eingänge ergibt sich &ndash; für jeden Porttyp
        getrennt &ndash; aus der Reihenfolge der entsprechenden
        <a href="#platzhalter">Platzhalter</a> in den Formeln.
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width: 180px">
          <col>
        </colgroup>
        <tr>
          <th>Bezeichnung</th>
          <th>Porttyp</th>
          <th>Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Bool</p>
          </td>
          <td>
            <p>
              Werte für Wahrheitswert-Platzhalter
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Integer</p>
          </td>
          <td>
            <p>
              Werte für Ganzzahl-Platzhalter
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Number</p>
          </td>
          <td>
            <p>
              Werte für Fließkommazahl-Platzhalter (auch Prozentwerte)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>
              Werte für Text-Platzhalter
            </p>
          </td>
        </tr>
      </table>
      <h2 id="ausgaenge">Ausgänge</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width: 180px">
          <col>
        </colgroup>
        <tr>
          <th>Bezeichnung</th>
          <th>Porttyp</th>
          <th>Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p>Ausgang 1<br />..<br />Ausgang <i>n</i></p>
          </td>
          <td>
            <p>je nach entsprechen-<br />dem Parameter<br /><a href="#parameter">Typ des Ausgangs</a></p>
          </td>
          <td>
            <p>
              Alle Ausgänge geben erst dann Werte aus, wenn <i>alle</i> Eingangswerte
              vorliegen. Wenn mehrere Formeln und Ausgänge verwendet werden, gilt dies
              auch für Formeln, in denen die fehlenden Werte gar nicht vorkommen.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                Eingangswerte, die weder abgefragt werden können noch zyklisch senden,
                sollten deshalb einen Vorgabewert haben.
              </li>
              <li>
                Werden unbenutzte Ausgänge nicht versteckt, so steht jeder Ausgang
                direkt neben dem <a href="#parameter">Formelparameter</a>, der ihn
                berechnet.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>Laufzeitfehler</p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>
              Einige Fehler, die in den Formeln auftreten können, werden bereits
              bei der Validierung festgestellt und im GPA ausgegeben.
            </p>
            <p>
              Viele Fehler lassen sich aber erst beim Berechnen der Ausgangswerte
              &ndash; also zur Laufzeit des Bausteins in der GPA-Simulation oder
              nach der Inbetriebnahme auf dem Zielgerät &ndash; feststellen. Solche
              Fehler werden an diesem Ausgang als Texte gemeldet.
            </p>
            <p>
              Beispiel: Der Fehler<br />
              <code>&nbsp;&nbsp;&nbsp;...: error CS1026: Unexpected symbol ',', expecting ')'</code><br />
              weist sehr wahrscheinlich darauf hin, dass in einer Fließkommazahl  Komma
              (<b>,</b>) statt Punkt (<b>.</b>) vor den Nach&shy;komma&shy;stellen steht.
              Anstelle von <code>...</code> steht, wo der Fehler zu suchen ist: In welcher
              Formel, in welcher Zeile (meist 1) und Zeichenposition.
            </p>
            <p>
              Hinweis: Die meisten Laufzeit-Fehlermeldungen werden &ndash; wie
              im Beispiel &ndash; in englischer Sprache ausgegeben.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="parameter">Parameter</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width:  70px">
          <col style="width: 110px">
          <col>
        </colgroup>
        <tr>
          <th>Bezeichnung</th>
          <th>Porttyp</th>
          <th>Als Eingang zuschaltbar?</th>
          <th>Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p>Anzahl der<br />Ausgänge<br />und Formeln</p>
          </td>
          <td>
            <p>Integer</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Dieser Parameter legt die Anzahl der Ausgänge des Bausteins im
              Bereich 1..50 fest. Da jeder Ausgang seine eigene Formel hat,
              legt dies auch die Anzahl der Formelparameter fest.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>Typ des<br />Ausgangs 1<br />..<br />Typ des<br />Ausgangs <i>n</i></p>
          </td>
          <td>
            <p>Auswahl</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Diese Parameter legen fest, welchen Porttyp der entsprechende
              Ausgangswert jeweils haben soll. Möglich sind die folgenden
              Typen (mit ihren C#-Entsprechungen):
            </p>
            <dl>
              <dt>NUMBER</dt>
              <dd>Fließkommazahl (<code>double</code>)</dd>
              <dt>INT64</dt>
              <dd>64-Bit-Ganzzahl mit Vorzeichen (<code>long</code>)</dd>
              <dt>INTEGER</dt>
              <dd>32-Bit-Ganzzahl mit Vorzeichen (<code>int</code>)</dd>
              <dt>BYTE</dt>
              <dd>8-Bit-Ganzzahl ohne Vorzeichen (<code>byte</code>)</dd>
              <dt>BOOL</dt>
              <dd>Wahrheitswert (<code>bool</code>)</dd>
              <dt>STRING</dt>
              <dd>Text (<code>string</code>)</dd>
            </dl>
            <p>
              In Klammern ist jeweils der C#-Typ angegeben, wie er in
              <a href="#operatoren">Typumwandlungsoperatoren</a>
              verwendet werden kann. Das Ergebnis der Formelauswertung muss
              sich in diesen Typ umwandeln lassen, sonst kann der Ausgang
              nicht gesetzt werden und es kommt zu einem Laufzeitfehler.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>Formel 1<br />..<br />Formel <i>n</i></p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Diese Parameter legen fest, wie die jeweiligen Ausgangswerte
              zu berechnen sind. Darin können <a href="#variablen">Variablen</a>,
              <a href="#konstanten">Konstanten</a>, <a href="#operatoren">Operatoren</a>,
              mathematische und andere <a href="#funktionen">Funktionen</a> und
              <a href="#kommentare">Kommentare</a> vorkommen. In den nächsten
              Kapiteln sind alle diese detailliert beschrieben.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="platzhalter">Platzhalter für Variablen</h2>
      <p>
        Platzhalter in den Formeln dienen dazu, variable Eingangswerte in den
        Berechnungen zu verwenden. Sie dürfen überall stehen, wo auch eine
        Konstante des gleichen Typs stehen dürfte.
      </p>
      <p>
        Es gibt zwei grundlegende Arten von Platzhaltern:
      </p>
      <ul>
        <li>
          <b>Definition</b> &ndash; definiert erstmals einen Eingang
          mit Namen und Typ und hat die folgende Form:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;<code>{</code><i>Eingangsname</i><code>:</code><i>T</i><code>}</code>
        </li>
        <li>
          <b>Referenz</b> &ndash; bezieht sich auf einen vorher definierten
          Eingang. Sie folgt der gleichen Form, wobei <code>:</code><i>T</i>
          weg gelassen werden darf.
        </li>
      </ul>
      <p>
        <i>Eingangsname</i> wird als <b>Bezeichnung des Baustein-Eingangs</b>
        verwendet. Definitionen legen Eingänge an und setzen deren Werte
        in die Formel ein. Referenzen beziehen sich auf einen vorher
        definierten Namen und verwenden den Wert des entsprechenden Eingangs
        erneut. Sie dürfen sich auch auf Namen beziehen, die in einer anderen
        Formel mit einer niedrigeren Nummer definiert worden sind. Referenzen
        dürfen keinen von der Definition abweichenden Datentyp festlegen.
      </p>
      <p>
        <i>Eingangsname</i> muss mit einem Buchstaben beginnen. Weiter kann
        er auch Ziffern (0..9) und Unterstriche (<code>_</code>) enthalten.
        Leerzeichen und andere Sonderzeichen sind nicht zulässig. Leerzeichen
        am Anfang oder am Ende sind erlaubt, werden aber nicht in den Namen
        übernommen.
      </p>
      <p>
        <i>T</i> ist ein Buchstabe, der den <b>Datentyp</b> des Eingangs
        festlegt.<br />
        Folgende Buchstaben &ndash; Groß- und Kleinbuchstaben haben gleiche
        Bedeutung &ndash; sind möglich:
      </p>
      <dl>
        <dt><code>B</code></dt>
        <dd>
          Wahrheitswert (<code>bool</code>) &ndash; Mögliche Werte: <code>true</code>, <code>false</code>
        </dd>
        <dt><code>I</code></dt>
        <dd>
          Ganzzahl (<code>int</code>) &ndash; Wertebereich -2 147 483 648 .. 2 147 483 647
        </dd>
        <dt><code>F</code>, <code>N</code>, <code>G</code> oder<sup> </sup><code>P</code></dt>
        <dd>
          Fließkommazahl (<code>double</code>) &ndash; Wertebereich etwa
          -1.7 × 10<sup>308</sup> .. 1.7 × 10<sup>308</sup>&nbsp;mit
          einer Genauigkeit von mindestens 15 geltenden Ziffern
        </dd>
        <dt><code>S</code></dt>
        <dd>
          Text (<code>string</code>) &ndash; ASCII-, ISO-8859-1- oder Unicode-Text
        </dd>
      </dl>
      <p>
        <b>Hinweis:</b><br />
        Bei numerischen Berechnungen sind die angegebenen Wertebereiche zu beachten.
        Werden sie in irgend einem Teil der Formel überschritten, kommt es zu
        falschen Ergebnissen.
      </p>
      <h2 id="eingangsvariablen">Welche Eingangswerte sind neu?</h2>
      <p>
        Für jeden Eingang wird eine Variable <code>bool _is</code><i>&lt;name&gt;</i><code>ValueSet_</code> angelegt. Diese gibt an, ob der Eingang für die laufende
        Berechnung ein neues Eingangstelegramm erhalten hat (<code>true</code>) oder
        ob der Wert von einem früheren Eingangstelegramm stammt (<code>false</code>).
        Ob sich der Eingangswert durch dieses Telegramm tatsächlich <i>geändert</i>
        hat (oder nur der gleiche Wert erneut empfangen worden ist), lässt sich
        daraus <i>nicht</i> ableiten. Das Beispiel <a href="#zustandsautomat">Zustandsautomat</a> zeigt eine Anwendung dieser Variablen.
      </p>
      <h2 id="ausgangsvariablen">Ausgangswerte als Variablen</h2>
      <p>
        Aktuelle und vorherige Ausgabewerte können in den Formeln als Variablen
        verwendet werden. Diese Variablen haben die Namen <code>_out1_</code> ..
        <code>_out49_</code> (für aktuelle Werte) bzw. <code>_previousOut1_</code> ..
        <code>_previousOut50_</code> (für vorherige Werte). Sie dürfen überall stehen,
        wo auch eine Konstante des gleichen Typs stehen dürfte.
      </p>
      <p>
        <em>Aktuelle</em> Werte sind solche, die seit der letzten Änderung
        eines Eingangs neu berechnet worden sind. Durch ihre Verwendung
        lassen sich große Formeln (oder solche, in denen Zwischenergebnisse
        mehrfach verwendet werden) in übersichtliche Teile zerlegen. Wird ein
        Zwischenergebnis nur in den weiteren Formeln (also nicht außerhalb des
        Bausteins) benötigt, so bleibt der entsprechende Ausgang unbelegt.
        Das Beispiel
        <a href="#hysterese">Verbesserter Schwellwert mit Hysterese</a>
        benutzt einen solchen Formelsatz.
      </p>
      <p>
        <em>Vorherige</em> Werte sind solche, die <em>zuletzt vor</em> der
        aktuellen Berechnung auf die Ausgänge gegeben worden sind. Dabei ist
        zu beachten, das <em>jede</em> Änderung eines Eingangs <em>alle</em>
        Formeln neu berechnet (auch solche die den geänderten Eingangswert
        gar nicht verwenden). Damit lassen sich u. a. einfache
        <a href="https://de.wikipedia.org/wiki/Endlicher_Automat">Zustandsautomaten</a>
        realisieren, wie im Beispiel <a href="#zustandsautomat">Zustandsautomat</a>
        gezeigt ist. Das Beispiel <a href="#summenzaehler">Summenzähler</a>
        zeigt eine weitere nützliche Anwendung dieser Variablen.
      </p>
      <p>
        Folgende Werte können in einer Formel verwendet werden, deren Nummer <i>n</i>
        sei:
      </p>
      <ul>
        <li>
          <em>Aktuelle</em> Werte können nur aus Formeln mit <em>niedrigeren</em>
          Nummern (<code>_out1_</code> .. <code>_out&lt;<i>n</i>-1&gt;_</code>) verwendet
          werden. Sie stehen also nur zur Verfügung, wenn es mehrere Formeln gibt.
          Dies vermeidet zyklische Abhängigkeiten.
        </li>
        <li>
          <em>Vorherige</em> Werte können aus <em>allen</em> Formeln verwendet
          werden. Das schließt die eigene und höhere Nummern
          (<code>_previousOut&lt;<i>n</i>&gt;_</code> ..) ein. (Zu zyklischen
          Abhängigkeiten führt das nicht, weil diese Werte erst wieder vor den
          Berechnungen für die <em>nächste</em> Änderung aktualisiert werden.)
        </li>
      </ul>
      <p>
        Nach einer Inbetriebnahme oder einem Neustart des Logikmoduls gibt es
        zunächst keine Werte aus vorherigen Berechnungen. Je nach Typ werden
        bis zum ersten Setzen eines Ausgangs <i>n</i> die folgenden Werte für
        <code>_previousOut&lt;<i>n</i>&gt;_</code> verwendet:
      </p>
      <dl>
        <dt>NUMBER</dt>
        <dd><code>0.0</code></dd>
        <dt>INT64, INTEGER, BYTE</dt>
        <dd><code>0</code></dd>
        <dt>BOOL</dt>
        <dd><code>false</code></dd>
        <dt>STRING</dt>
        <dd><code>""</code> (Leerstring)</dd>
      </dl>
      <h2 id="konstanten">Literale Konstanten</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 100px">
          <col style="width: 100px">
          <col>
        </colgroup>
        <tr>
          <th>Konstante</th>
          <th>Datentyp</th>
          <th>Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p><i>Zahl</i></p>
          </td>
          <td>
            <p><code>byte<br />integer<br />long<br />double</code></p>
          </td>
          <td>
            <p>
              Zahlen, die ohne Dezimaltrennzeichen angegeben werden, also nur aus
              Ziffern bestehen, sind Ganzzahlen (<code>int</code>). Dies ist insbesondere
              beim Dividieren zu beachten (siehe Divisions-Operator).
            </p>
            <p>
              Ganzzahlen können auch in hexadezimaler Schreibweise angegeben werden,
              indem man ihnen <code>0x</code>... voran stellt. Weitere Details finden sich
              im Abschnitt
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#integer-literals">Ganzzahlenliterale</a>
              der C#-Sprachreferenz von Microsoft.
            </p>
            <p>
              Fließkommazahlen (<code>double</code>) können auch in Exponentialschreibweise
              angegeben werden. Z. B. bedeutet <code>1.2E6</code> dasselbe wie
              <code>1200000.0</code> und <code>-3.45E-3</code> dasselbe wie <code>-0.00345</code>.
              Als Dezimaltrenzeichen für Fließkomazahlen ist in Formeln &ndash;
              anders als in sonstigen Eingabefeldern &ndash; immer Punkt (<b>.</b>)
              zu verwenden. Gruppentrennzeichen (Tausendertrennzeichen) sind nicht
              zulässig.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>true<br />false</code></p>
          </td>
          <td>
            <p><code>bool</code></p>
          </td>
          <td>
            <p>Logische Wahrheitswerte.</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>Math.PI</code></p>
          </td>
          <td>
            <p><code>double</code></p>
          </td>
          <td>
            <p>
              Die Kreiszahl
              (<span style="font-family: 'Times New Roman', Times, serif; font-size:larger;">&pi;</span>
              = 3.141...)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>Math.E</code></p>
          </td>
          <td>
            <p><code>double</code></p>
          </td>
          <td>
            <p>
              Die Eulersche Zahl
              (<span style="font-family: 'Times New Roman', Times, serif; font-size:larger;">e</span>
              = 2.718...)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>DateTime.<br />&nbsp;&nbsp;Today<br />&nbsp;&nbsp;Now</code></p>
          </td>
          <td>
            <p><code>DateTime</code></p>
          </td>
          <td>
            <p>
              Nicht wirklich Konstanten, da die Werte vom Zeitpunkt des Aufrufs abhängen:<br />
              Aktuelles Datum (<code>Today</code> mit Uhrzeit 0:00 Uhr; <code>Now</code>
              mit aktueller Uhrzeit)
            </p>
            <p>
              Hinweis: Objekte vom Typ <code>DateTime</code> sind nicht direkt als
              Ausgabewerte verwendbar. Nützlich sind sie für Berechnungen mit Daten
              und Uhrzeiten, die anders nicht ohne Weiteres möglich wären. Sie lassen
              sich auch in gültige Ausgabetypen (Zahlen oder Texte) umwandeln. Siehe
              dazu die
              <a href="https://docs.microsoft.com/de-de/dotnet/api/system.datetime?view=netframework-4.0">Dokumentation der <code>DateTime</code>-Klasse</a>
              und das <a href="#feiertag">Anwendungsbeispiel "Feiertag"</a>.
              Korrekt formatierte Texte kann der Gira-Typumwandler auch wieder
              in DateTime-Datenpunkte umwandeln.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>"</code><i>Text</i><code>"</code></p>
          </td>
          <td>
            <p><code>string</code></p>
          </td>
          <td>
            <p>
              Literale ASCII- oder Unicode-Text-Konstante
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>null</code></p>
          </td>
          <td>
            <p>&mdash;</p>
          </td>
          <td>
            <p>
              Das typlose "nichts" kann überall stehen wo ein beliebiger
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/builtin-types/nullable-value-types">auf NULL festlegbarer Typ</a>
              zulässig ist. Nützlich ist das vor allem, wenn man in einem
              Zweig eines Bedingungsoperators <em>keinen</em> Wert an einen
              Ausgang senden möchte. Für Ausgänge vom Typ STRING funktioniert
              das direkt. Für alle anderen Ausgangstypen muss man im anderen
              Zweig des Bedingungsoperators explizit die auf NULL festlegbare
              Variante des Ausgabetyps verwenden. Das Beispiel
              <a href="#hysterese">Verbesserter Schwellwert mit Hysterese</a>
              zeigt, wie man das mit Typumwandlungs-Operatoren erreicht.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="operatoren">Operatoren</h2>
      Alle
      <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/">C#-Operatoren</a>,
      die sich auf verfügbare Datentypen anwenden lassen, sind zulässig.
      Die wichtigsten davon sind:
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width:  55px">
          <col style="width:  85px">
          <col style="width: 100px">
          <col style="width: 108px">
          <col style="width:  95px">
          <col>
        </colgroup>
        <tr>
          <th>Rang-folge</th>
          <th>Assozia-tivität</th>
          <th>Operator</th>
          <th>Bezeichnung</th>
          <th>Datentypen</th>
          <th>Beschreibung und Beispiel</th>
        </tr>
        <tr>
          <td rowspan="2">
            <p style="margin-top:42px;">&nbsp;&nbsp;1</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:34px;">Von rechts nach links </p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>+ &nbsp; -</code></p>
          </td>
          <td>
            <p style="margin-top:16px;">Vorzeichen</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p>
              Kein Vorzeichen oder <code>+</code> wertet den nachfolgenden Ausdruck
              positiv, <code>-</code> negativ. Beispiel: <code>-1.6</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;"><code>!</code></p>
          </td>
          <td>
            <p style="margin-top:16px;">NICHT</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>bool</code></p>
          </td>
          <td>
            <p>
              Invertiert den nachfolgenden booleschen Ausdruck (<code>true</code>
              &rarr; <code>false</code>; <code>false</code> &rarr; <code>true</code>).
              Beispiel: <code>!{offen:B}</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;2</p>
          </td>
          <td>
            <p>Von rechts nach links</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>(</code><i>T</i><code>)</code></p>
          </td>
          <td>
            <p>Typumwand-<br />lung (Cast)</p>
          </td>
          <td>
            <p><i>alle</i> &rarr; <i>T</i></p>
          </td>
          <td>
            <p>
              Erzwingt eine Typumwandlung des nachfolgenden Ausdrucks auf
              <i>T</i>. Für <i>T</i> können &ndash; über die an Ein- und Ausgängen
              möglichen Typen hinaus &ndash; auch viele andere
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/keywords/value-types-table">Werttypen von C#</a>
              stehen.
            </p>
            <p>Beispiel: <code>(int)Math.Round({x:N})</code></p>
          </td>
        </tr>
        <tr>
          <td rowspan="2">
            <p style="margin-top:130px;">&nbsp;&nbsp;3</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:122px;">Von links nach rechts</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>* &nbsp; /</code></p>
          </td>
          <td>
            <p>Punkt-Grund-rechenarten</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p>
              Hinweise:
            </p>
            <p>
              Bei der Division von Ganzzahlen wird das Ergebnis nicht
              gerundet, sondern eventuelle Nachkommastellen einfach
              abgeschnitten. Man vergleiche die folgenden Beispiele:
            </p>
            <ul>
              <li><code>-3 / 2</code> &nbsp; &rarr; &nbsp; <code>-1</code></li>
              <li><code>-3.0 / 2</code> &nbsp; &rarr; &nbsp; <code>-1.5</code></li>
              <li>
                <code>Math.Round(((double)-3) / 2)</code> &nbsp; &rarr;
                &nbsp; <code>-2.0</code>
              </li>
            </ul>
            <p>
              Um Fließkommazahlen auf Ganzzahlen zu runden, braucht man
              übrigens keine Formelberechnung, das kann schon der
              Typkonverter von Gira.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;"><code>%</code></p>
          </td>
          <td>
            <p style="margin-top:16px;">Divisionsrest</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>int</code></p>
          </td>
          <td>
            <p>
              Ergibt den Divisionsrest einer ganzzahlingen Division.<br />
              Beispiel: <code>5 % 3</code> &rarr; <code>2</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;4</p>
          </td>
          <td>
            <p>Von links nach rechts</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>+ &nbsp; -</code></p>
          </td>
          <td>
            <p>Strich-Grund-rechenarten</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p style="margin-top:16px;">
              <code>+</code> dient auch zur Verkettung von Texten (C#-Typ <code>string</code>).
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;5</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">Von links nach rechts</p>
          </td>
          <td>
            <p><code>&lt; &nbsp;&gt; &nbsp;&lt;= &nbsp;&gt;=</code></p>
          </td>
          <td>
            <p>Relational</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">
              <i>alle<br />Zahltypen</i><br />&rarr; <code>bool</code>
            </p>
          </td>
          <td rowspan="2">
            <p style="margin-top:10px;">
              Vergleicht zwei Werte und ergibt <code>true</code>, wenn der
              Vergleichsoperator zutrifft, sonst <code>false</code>.
            </p>
            <p>
              Beispiel: <code>{temperatur:N} > 21.5</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;6</p>
          </td>
          <td>
            <p style="margin-top:16px;"><code>== &nbsp; !=</code></p>
          </td>
          <td>
            <p>Gleichheit,<br />Ungleichheit</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;7</p>
          </td>
          <td rowspan="3">
            <p style="margin-top:36px;">
              Von links nach rechts
            </p>
          </td>
          <td>
            <p><code>&amp;</code></p>
          </td>
          <td>
            <p>UND</p>
          </td>
          <td rowspan="3">
            <p style="margin-top:44px;"><code>bool</code></p>
          </td>
          <td rowspan="3">
            <p style="margin-top:10px;">
              Logische Operatoren mit vollständiger Auswertung.
            </p>
            <p>
              Hinweis:<br />
              Der sonst übliche Operator <code>x^y</code> (x<sup>y</sup>) für
              Zahlen steht nicht zur Verfügung. Man verwendet dazu die
              <a href="#funktionen">Funktion</a> <code>Math.Pow</code>.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;8</p>
          </td>
          <td>
            <p><code>^</code></p>
          </td>
          <td>
            <p>Exklusiv-ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;9</p>
          </td>
          <td>
            <p><code>|</code></p>
          </td>
          <td>
            <p>ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>10</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">
              Von links nach rechts
            </p>
          </td>
          <td>
            <p><code>&amp;&amp;</code></p>
          </td>
          <td>
            <p>UND</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:26px;"><code>bool</code></p>
          </td>
          <td rowspan="2">
            <p style="margin-top:4px;">
              Logische Operatoren mit bedingter Auswertung, d. h. die Auswertung erfolgt nur
              so weit, bis das Ergebnis feststeht.
            </p>
            <p>Beispiel: <code>/* Fenster geschlossen */ !{offen:B} && !{gekippt:B}</code></p>
          </td>
        </tr>
        <tr>
          <td>
            <p>11</p>
          </td>
          <td>
            <p><code>||</code></p>
          </td>
          <td>
            <p>ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:19px;">12</p>
          </td>
          <td>
            <p style="margin-top:10px;">Von rechts nach links</p>
          </td>
          <td>
            <p style="margin-top:19px;"><i>b</i><code> ? </code><i>x</i><code> : </code><i>y</i></p>
          </td>
          <td>
            <p style="margin-top:19px;">Bedingung</p>
          </td>
          <td>
            <p style="margin-top:19px;"><code>bool</code> &rarr; <i>alle</i></p>
          </td>
          <td>
            <p style="margin-top:4px;">
              Gibt <i>x</i> zurück, wenn <i>b</i> <code>true</code> ist, sonst <i>y</i>.
            </p>
            <p>Beispiel: <code> ({istVerriegelt:B} ? "verriegelt" : "offen"</code></p>
          </td>
        </tr>
      </table>
      <p>
        Die ersten beiden Spalten der Tabelle geben an, wie nicht geklammerte
        Ausdrücke ausgewertet werden. Darin ist z. B. auch die bekannte Regel
        "Punkt vor Strich" enthalten: <code>*</code> und <code>/</code> werden vor
        <code>+</code> und <code>-</code> ausgewertet. Geklammerte Ausdrücke
        <code>(</code>...<code>)</code> werden "von innen nach außen" berechnet.
        Weitere Angaben dazu finden sich im Abschnitt
        <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/#operator-precedence">Operatorrangfolge</a>
        der C#-Sprachreferenz.
      </p>
      <p>
        Obwohl Variablendeklarationen und Zuweisungen in Formeln generell
        nicht erlaubt sind, können dennoch temporäre Objekte mit dem
        <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/new-operator"><code>new</code>-Operator</a>
        erzeugt und innerhalb einer Formel verwendet werden. Das Beispiel
        <a href="#zeitstempel">UNIX-UTC-Zeitstempel umwandeln</a>
        zeigt eine nützliche Anwendung.
      </p>
      <h2 id="funktionen">Funktionen</h2>
      <p>
        Soweit ihre Parameter- und Rückgabetypen sinnvoll verwendbar sind,
        stehen viele Klassen des
        <a href="https://docs.microsoft.com/de-de/dotnet/api/?view=netframework-4.0">gut in deutscher Sprache dokumentierten .NET 4.0 APIs</a>
        mit ihren Funktionen zur Verfügung. Dieses Kapitel geht nur auf
        einige besonders nützliche Bereiche und Besonderheiten ein.
      </p>
      <p>
        Neben dem .NET-Framework stehen eigene Erweiterungen vor allem zur
        <a href="#light">Beleuchtungs-</a> und <a href="#HLK">Klimatechnik</a>
        zur Verfügung.
      </p>
      <h3 id="math">Mathematische Funktionen: Math-Bibliothek und Erweiterungen</h3>
      <p>
        Die meisten
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.math?view=netframework-4.0#methoden"><b>Math</b>-Methoden des .NET-4.0-Standards</a>
        können in den Formeln verwendet werden.
      </p>
      <p>
        Beispiel: <code>Math.Pow({x:N},{y:N})</code> berechnet aus den beiden Eingangswerten
        x und y deren Potenz x<sup>y</sup>.
      </p>
      <p>
        Die trigonometrischen Funktionen der <code>Math</code>-Bibliothek verwenden
        und liefern alle Winkelangaben im Bogenmaß. Zur Umrechnung zwischen Grad-
        und Bogenmaß stehen die folgenden beiden Funktionen der
        <code>Angle</code>-Erweiterung zur Verfügung:
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th class="small">Funktion</th>
          <th class="small">Datentyp</th>
          <th class="small">Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p><code>Angle.Deg(</code><i>rad</i><code>)</code></p>
          </td>
          <td>
            <p><code>double</code></p>
          </td>
          <td>
            <p>Rechnet den im Bogenmaß gegebenen Winkel <i>rad</i> ins Gradmaß um.</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>Angle.Rad(</code><i>deg</i><code>)</code></p>
          </td>
          <td>
            <p><code>double</code></p>
          </td>
          <td>
            <p>Rechnet den im Gradmaß gegebenen Winkel <i>deg</i> ins Bogenmaß um.</p>
          </td>
        </tr>
      </table>
      <p>
        In der <code>Math</code>-Bibliothek stehen Funktionen zur Berechnung von
        Minima und Maxima nur mit zwei Parametern zur Verfügung. Oft benötigt man
        aber mehr Eingabewerte. Um dann keine unschöne Schachtelung anwenden zu
        müssen, gibt es die folgenden beiden Methoden, die beliebig viele Parameter
        verarbeiten können:
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th class="small">Funktion</th>
          <th class="small">Datentyp</th>
          <th class="small">Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p>
              <code>MoreMath.Min(</code><i>value1</i><code>
                ,
              </code><i>value2</i><code>, </code><i>...</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>double</code> oder <code>int</code></p>
          </td>
          <td>
            <p>Gibt den niedrigsten Wert unter den gegebenen Parametern zurück.</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>MoreMath.Max(</code><i>value1</i><code>
                ,
              </code><i>value2</i><code>, </code><i>...</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>double</code> oder <code>int</code></p>
          </td>
          <td>
            <p>Gibt den höchsten Wert unter den gegebenen Parametern zurück.</p>
          </td>
        </tr>
      </table>
      <h3 id="string">Funktionen zur Textbearbeitung</h3>
      <p>
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.double.tostring?view=netframework-4.0">ToString</a>
        mit seinen verschiedenen Varianten für alle numerischen Typen erlaubt die
        sehr flexible Formatierung von Zahlen als Texte. Auch können fast alle
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.string?view=netframework-4.0#methoden"><b>String</b>-Methoden des .NET-4.0-Standards</a>
        verwendet werden.
      </p>
      <p>
        Beispiel Textersetzung: Mit <code>{text:S}.Replace("alt","neu")</code>
        wird der Eingangstext: "<i>Alles alt macht der Mai</i>" am Ausgang zu
        "<i>Alles neu macht der Mai</i>".
      </p>
      <h3 id="light">Funktionen zur Beleuchtungssteuerung</h3>
      <p>
        Die Funktionen der <code>Light</code>-Erweiterung rechnen gängige Größen
        der Beleuchtungstechnik um:
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th class="small">Funktion</th>
          <th class="small">Datentyp</th>
          <th class="small">Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p><code>Light.HSV(</code><i>h</i><code>, </code><i>s</i><code>, </code><i>v</i><code>)</code></p>
          </td>
          <td>
            <p><code>byte</code> &rarr; <code>int</code></p>
          </td>
          <td>
            <p>
              Rechnet die als einzelne 8-Bit-Werte (DPT 5.x) gegebenen Farbgrößen für
              Farbwert (<i>h</i>ue), Farbsättigung (<i>s</i>aturation) und Hellwert
              (<i>v</i>alue) in eine kombinierte HSV-Größe (3 Bytes, ähnlich zu DPT
              232.600) um.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                Da Byte-Eingänge nicht vorgesehen sind, muss der Typumwandlungsoperator
                verwendet werden, um Integer-Eingänge als byte-Parameter verwenden zu
                können:
                <div class="box-noscroll" style="width: 565px;"> <code>Light.HSV((byte){h:I}, (byte){s:I}, (byte){v:I})</code></div>
              </li>
              <li>
                Für Integer-Werte außerhalb des Wertebereichs 0..255 führt dies zu
                unerwünschtem Verhalten. Es ist also sicher zu stellen, dass die
                Integer-Werte im gültigen Wertebereich bleiben. Dies ist z. B. der
                Fall, wenn sie aus DPT-5.x-Eingängen &ndash; oder ganz allgemein aus
                Bausteinen mit Byte-Ausgängen &ndash; stammen.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>Light.HSVToH(</code><i>hsv</i><code>)</code>
              <code>Light.HSVToS(</code><i>hsv</i><code>)</code>
              <code>Light.HSVToV(</code><i>hsv</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>int</code> &rarr; <code>byte</code></p>
          </td>
          <td>
            <p>
              Extrahiert aus der gegebenen kombinierten HSV-Größe <i>hsv</i> (3 Bytes,
              ähnlich zu DPT 232.600) die einzelnen 8-Bit-Farbgrößen (DPT 5.x) für
              Farbwert (<b>H</b>ue), Farbsättigung (<b>S</b>aturation) oder Hellwert
              (<b>V</b>alue).
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>Light.RGB(</code><i>r</i><code>, </code><i>g</i><code>, </code><i>b</i><code>)</code></p>
          </td>
          <td>
            <p><code>byte</code> &rarr; <code>int</code></p>
          </td>
          <td>
            <p>
              Rechnet die als einzelne 8-Bit-Werte (DPT 5.x) gegebenen Farbintensitäten
              für <i>r</i>ot, <i>g</i>rün und <i>b</i>lau in eine kombinierte RGB-Größe
              (3 Bytes, DPT 232.600) um.
            </p>
            <p>
              Die bereits oben zu <code>byte</code>-Parametern gegebenen Hinweise gelten
              entsprechend.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>Light.RGBToR(</code><i>rgb</i><code>)</code>
              <code>Light.RGBToG(</code><i>rgb</i><code>)</code>
              <code>Light.RGBToB(</code><i>rgb</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>int</code> &rarr; <code>byte</code></p>
          </td>
          <td>
            <p>
              Extrahiert aus der gegebenen kombinierten RGB-Größe <i>rgb</i> (3 Bytes,
              DPT 232.600) die einzelnen 8-Bit-Farbintensitäten (DPT 5.x) für
              <b>R</b>ot, <b>G</b>rün oder <b>B</b>lau.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>Light.RGBW(</code><i>rgb</i><code>)</code>
              <code>Light.RGBW(</code><i>r</i><code>, </code><i>g</i><code>, </code><i>b</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>int</code> &rarr; <code>long</code><br /><code>byte</code> &rarr; <code>long</code></p>
          </td>
          <td>
            <p>
              Rechnet die gegebene RGB-Größe &ndash; wahlweise einzelne 8-Bit-Werte (DPT 5.x)
              oder 3 Bytes kombiniert (DPT 232.600) &ndash; in eine kombinierte RGBW-Größe
              (6 bytes, DPT 251.600) um. Die Umrechnung extrahiert die gemeinsame Helligkeit
              aller Farben in einen entsprechenden Wert für <i>w</i>eiß. Die Farbintensitäten
              für <i>r</i>ot, <i>g</i>rün und <i>b</i>lau werden so weit reduziert, dass
              mindestens eine dieser Farben ganz weg fällt.
            </p>
            <p>
              Alle vier Werte im erzeugten DPT 251.600 sind gültig (und auch so markiert).
              Die bereits oben zu <code>byte</code>-Parametern gegebenen Hinweise gelten
              entsprechend.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><code>Light.RGBW(</code><i>r</i><code>, </code><i>g</i><code>, </code><i>b</i><code>, </code><i>w</i><code>)</code></p>
          </td>
          <td>
            <p><code>int</code> &rarr; <code>long</code></p>
          </td>
          <td>
            <p>
              Rechnet die gegebenen Farbintensitäten für <i>r</i>ot, <i>g</i>rün, <i>b</i>lau
              und <i>w</i>eiß in eine kombinierte RGBW-Größe (6 bytes, DPT 251.600) um. Gültige
              Intensitäten liegen im Wertebereich 0..255. Werte außerhalb dieses Bereichs werden
              als 0 übernommen und ungültig markiert.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>Light.RGBWToR(</code><i>rgbw</i><code>)</code>
              <code>Light.RGBWToG(</code><i>rgbw</i><code>)</code>
              <code>Light.RGBWToB(</code><i>rgbw</i><code>)</code>
              <code>Light.RGBWToW(</code><i>rgbw</i><code>)</code>
            </p>
          </td>
          <td>
            <p><code>long</code> &rarr; <code>int</code></p>
          </td>
          <td>
            <p>
              Extrahiert aus der kombinierten RGBW-Größe <i>rgbw</i> (6 bytes, DPT 251.600)
              gültige Intensitäten für <b>R</b>ot, <b>G</b>rün, <b>B</b>lau oder <B>W</B>eiß
              im 8-Bit-Wertebereich 0..255. Als ungültig markierte Intensitäten werden mit
              dem Wert -1 zurück gegeben.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                DPT 251.600 hat 6 Bytes, von denen 36 Bits verwendet werden. Da
                Ganzzahl-Eingänge mit dem benötigten Wertebereich nicht zur
                Verfügung stehen, muss ein Fließkommazahl-Eingang und ein
                Typumwandlungsoperator verwendet werden; z. B.:
                <div class="box-noscroll" style="width: 565px;"> <code>RGBWToB((long){r:N})</code></div>
              </li>
              <li>
                Wenn im Eingabewert Intensitäten als ungültig markiert sein können, dann
                dürfen die Ausgabewerte nicht ohne Weiteres einem 8-Bit-Objekt (DPT 5.x)
                zugewiesen werden. Vielmehr ist der Ausgabewert -1 gesondert zu behandeln.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <code>Light.RGBToHSV(</code><i>r</i><code>, </code><i>g</i><code>, </code><i>b</i><code>)</code>
              <code>Light.RGBToHSV(</code><i>rgb</i><code>)</code>
              <code>Light.HSVToRGB(</code><i>h</i><code>, </code><i>s</i><code>, </code><i>v</i><code>)</code>
              <code>Light.HSVToRGB(</code><i>hsv</i><code>)</code>
            </p>
          </td>
          <td>
            <p>
              <code>byte</code> &rarr; <code>int<br />int</code> &rarr; <code>int</code><br />
              <code>byte</code> &rarr; <code>int<br />int</code> &rarr; <code>int</code>
            </p>
          </td>
          <td>
            <p>
              Rechnet Farbangaben zwischen dem RGB-Farbraum und dem HSV-Farbraum um.
            </p>
            <p>
              Die bereits oben zu <code>byte</code>-Parametern und DPT 232.600 gegebenen
              Hinweise gelten <span class="manhyphens">entsprechend</span>.
            </p>
          </td>
        </tr>
      </table>
      <p>
        Mit diesen Funktionen lässt sich z. B. aus einem HSV-Controller eine
        RGBW-LED-Leiste ansteuern.
      </p>
      <h3 id="HLK">Funktionen für die Heizungs-, Lüftungs- und Klimatechnik (HLK)</h3>
      <p>
        Die Funktionen der <code>Hlk</code>-Erweiterung helfen bei der Realisierung
        von Heizungs- und Lüftungsreglern.
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th class="small">Funktion</th>
          <th class="small">Datentyp</th>
          <th class="small">Beschreibung</th>
        </tr>
        <tr>
          <td>
            <p><code>Hlk.HeatingCurve<br />(</code><i>TaAvg</i><code>, </code><i>...</i><code>)</code></p>
          </td>
          <td>
            <p><code>double</code></p>
          </td>
          <td>
            <p>
              Errechnet aus der gedämpften (zeitlich gemittelten) Außentemperatur <i>TaAvg</i>
              in °C und weiteren Parametern die benötigte Vorlauftemperatur für einen Heizkreis.
              Die Parameter passen die Heizkurve an die Gegebenheiten des Gebäudes und der
              Heizungsanlage an. Aufgrund des Umfangs findet sich die genaue Beschreibung dieser
              Funktion und ein Anwendungsbeispiel
              <a href="HeatingCurve.html">auf einer eigenen Seite</a>.
            </p>
          </td>
        </tr>
        <tr>
          <td class="group" colspan="3">
            <p>
              Viele Außen- und Raumsensoren können Temperatur (in °C) und relative Luftfeuchtigkeit
              (in %) messen. Die folgenden Funktionen errechnen daraus andere in der Lüftungs- und
              Klimatechnik wichtige Größen:
            </p>
          </td>
        </tr>
        <tr>
          <td class="group">
            <p><code>Hlk.AbsHumidity(</code><i>T</i><code>, </code><i>rf</i><code>)</code></p>
          </td>
          <td class="group">
            <p><code>double</code></p>
          </td>
          <td class="group">
            <p>
              Errechnet aus der Temperatur <i>T</i> in °C und der relativen
              Luftfeuchtigkeit <i>rf</i> in % die absolute Luftfeuchtiggkeit
              (in g/m<sup>3</sup>). Dieser Wert gibt an, wie viel Wasserdampf
              in einem Kubikmeter Luft enthalten ist.
            </p>
          </td>
        </tr>
        <tr>
          <td class="group">
            <p><code>Hlk.DewPoint(</code><i>T</i><code>, </code><i>rf</i><code>)</code></p>
          </td>
          <td class="group">
            <p><code>double</code></p>
          </td>
          <td class="group">
            <p>
              Errechnet aus der Temperatur <i>T</i> in °C und der relativen
              Luftfeuchtigkeit <i>rf</i> in % die Taupunkt-Temperatur (in °C).
              Dieser Wert gibt an, bei welcher Temperatur die relative
              Luftfeuchtigkeit 100% wäre, der Wasserdampf also gerade anfangen
              würde zu kondensieren.
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="3">
            <p>
              Da exakte Berechnungsverfahren nicht existieren, liefern beide
              Funktionen gute Näherungswerte auf der Grundlage der
              <a href="http://www.wetterochs.de/wetter/feuchte.html">Magnusformel</a>.
            </p>
            <p>
              Sie können beispielsweise dazu dienen, eine Lüftungsanlage (von
              der wir annehmen wollen, dass sie keinen Luftentfeuchter hat)
              bedarfsgerecht (also nicht unnötig) und zielorientiert (also
              nicht kontraproduktiv) zu steuern. So hat es z. B. keinen Sinn,
              einem Raum absolut feuchtere Außenluft zuzuführen, wenn
              Luftfeuchtigkeit und Taupunkt-Temperatur ohnehin schon höher
              sind als gewünscht.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="kommentare">Kommentare</h2>
      <p>
        Die Formeln können mit Kommentaren in der Form
        <span class="box-noscroll"> <code>/* ... */</code> </span> dokumentiert
        werden. Darin kann anstelle von <code>...</code> nahezu beliebiger Text
        stehen. Solche Kommentare &ndash; auch mehrere davon &ndash; können
        am Anfang, am Ende oder an anderen Stellen der Formel stehen.
      </p>
      <h2 id="beispiele">Beispiele</h2>
      <p>
        Das <a href="HeatingCurve.html#heizbeispiel">
          Anwendungsbeispiel
          "Bedarfsgeführte Heizungsregelung"
        </a> findet sich bei der
        <a href="HeatingCurve.html">Beschreibung der Funktion HeatingCurve</a>.
      </p>
      <h3 id="feiertag">Feiertage</h3>
      <p>
        An Feiertagen und ihren Vortagen sollen bestimmte
        Automatisierungsfunktionen anders ablaufen als an normalen
        Werktagen. Die folgende Formel berechnet dazu zunächst das
        morgige Datum als STRING:<br />
        <span class="box-noscroll"> <code>DateTime.Today.AddDays(1).ToString("d") /* Datum für Morgen errechnen */</code> </span><br />
      </p>
      <p>
        Dieses dient als Parameter für eine Web-Anfrage mittels
        <a href="https://github.com/daniel-kun/Albuschat.LogicNodes/releases">Web Request</a> oder
        <a href="http://service.knx-user-forum.de/?comm=download&id=20000065">HTTP GET Request</a>.
        Der Request-Baustein wird mit folgender URL parametriert:<br />
        <span class="box-noscroll"> <code>http://ipty.de/feiertag/api.php?do=isFeiertag&loc=BW&datum={Morgen}</code> </span><br />
        Ein zweiter Request-Baustein verwendet fast die gleiche URL, aber
        ohne den Datumsparameter (was implizit "heute" bedeutet):
        <span class="box-noscroll"> <code>http://ipty.de/feiertag/api.php?do=isFeiertag&loc=BW</code> </span><br />
        In beiden steht <code>BW</code> für das Bundesland Baden-Württemberg;
        die Kürzel für andere Bundesländer entnimmt man der
        <a href="http://ipty.de/feiertag/">Online-Dokumentation</a>
        des Webservices.
      </p>
      <p>
        Das komplette Logikblatt sieht so aus &ndash; wieder mit beispielhaften
        Simulationsdaten:
        <img src="ExpressionCalculatorExample2.png" alt="" class="example" />
      </p>
      <p>
        Der Triggereingang löst eine neue Formelauswertung aus. Er wird an
        die Request-Bausteine nur durch gereicht (Ausgangstyp BOOL). Er sollte
        täglich kurz nach Mitternacht eine 1 erhalten. Wir nutzen, dass die
        Formelberechnung <i>alle</i> Formeln neu rechnet, sobald sich <i>ein</i>
        Eingangswert ändert: Die Datumsberechnung hat <i>gar keinen</i>
        Eingangswert, wird aber dennoch angestoßen, sobald ein Trigger
        eintrifft.
      </p>
      <h3 id="zeitstempel">UNIX-UTC-Zeitstempel umwandeln</h3>
      <p>
        Viele Webservices verwenden für Datums- und Zeitangaben Ganzzahlen als
        Zeitstempel. Inhalt ist die Anzahl der Sekunden seit dem 1.1.1970, 0:00
        Uhr. Meist sind diese nicht in lokaler Zeit, sondern in "Koordinierter
        Weltzeit" (französisch "Temps universel coordonné", Abkürzung UTC)
        angegeben. Um solche Zeitangaben in einer Visualisierung verwenden zu
        können, muss man sie zu einem Text in lokaler Zeit wandeln. Das tut die
        folgende Formel:<br />
        <span class="box-noscroll"> <code>(new DateTime(1970,1,1,0,0,0,0,DateTimeKind.Utc)).AddSeconds({unixUtcTimestamp:I}).ToLocalTime().ToString()</code> </span><br />
        Der <code>new</code>-Operator erzeugt zunächst ein <code>DateTime</code>-Objekt
        mit dem richtigen Startzeitpunkt. Nach dem Addieren der Sekunden des
        UTC-Zeitstempels wandeln zwei weitere Funktionen das Objekt in den
        gewünschten Text um.
      </p>
      <p>
        Da dieser kombinierte Datums- und Zeit-Text länger als 14 Zeichen ist,
        kann er nicht auf dem KNX-Bus versendet, sondern nur innerhalb des L1/X1
        verwendet werden. Abhilfe schaffen im Bedarfsfall z. B.
      </p>
      <ul>
        <li>
          die Funktionen <code>DateTime.ToShortDateString</code> und
          <code>DateTime.ToShortTimeString</code>, die kürzere Texte
          getrennt nach Datum und Uhrzeit erzeugen
        </li>
        <li>
          ein Typ-Konverter, der aus Text einen Datenpunkt vom Typ
          "Datum und Uhrzeit" erzeugen kann. Dazu verwendet man
          zweckmäßig folgenden Parameter im letzten Funktionsaufruf
          der Formel:
          <span class="box-noscroll"> <code>...ToString(<b>"s"</b>)</code> </span>.
          (Ohne diesen werden evtl. Tag und Monat vertauscht, weil der
          Gira-Typ-Konverter das Textformat nicht richtig erkennt.)
        </li>
      </ul>
      <h3 id="hysterese">Verbesserter Schwellwert mit Hysterese</h3>
      <p>
        Der Gira-Baustein "Schwellwert mit Hysterese" setzt seinen Ausgang nur
        dann neu, wenn ein neuer Auslöser-Wert eintrifft. Ändern sich nur die
        Schwellwerte, so bleibt dies ohne Wirkung. Oft ist deshalb zusätzlich
        Logik mit einem Wertgenerator für den Auslöser notwendig, um das
        gewünschte Verhalten zu erreichen. Man erhält in diesen Fällen
        übersichtlichere Logikblätter mit weniger Bausteinen, wenn man eine
        Formelberechnung mit folgenden Formeln einsetzt:<br />
        Formel 1: <span class="box-noscroll"> <code>{Auslöser:N} &gt; {ObereSchwelle:N}</code> </span><br />
        Formel 2: <span class="box-noscroll"> <code>{Auslöser:N} &lt; {UntereSchwelle:N}</code> </span><br />
        Formel 3: <span class="box-noscroll"> <code>_out1_ ? (bool?)true : (_out2_ ? (bool?)false : /* nichts senden */ null)</code> </span>
      </p>
      <p>
        Alle drei Ausgänge sind vom Typ BOOL. Der dritte gibt das gewünschte
        Endergebnis aus; die ersten beiden bleiben daher unbelegt. Solange
        der Auslöser zwischen den beiden Schwellwerten liegt, ergeben die
        beiden ersten Formeln jeweils <code>false</code>. Formel 3 gibt in
        diesem Fall <em>nichts</em> aus.
      </p>
      <p>Hinweise:</p>
      <ul>
        <li>
          Anders als beim Gira-Baustein "Schwellwert mit Hysterese" bleibt
          der Ausgang mit dieser Formel so lange undefiniert, bis ein
          Eingangstelegramm eintrifft, dessen Wert entweder unterhalb der
          unteren oder oberhalb der oberen Schwelle liegt. Man sollte daher
          die Eingangswerte nachfolgender Bausteine geeignet vorbelegen,
          sonst werden diese möglicherweise nach einem Neustart für längere
          Zeit nicht ausgeführt.
        </li>
        <li>
          Wie beim Original-Gira-Baustein gibt es sinnvolle Ausgabewerte nur,
          wenn die Schwellwerte nicht vertauscht werden. Im einfachsten Fall
          legt man dazu direkt in der ersten Formel den oberen Schwellwert auf
          eine höhere Zahl als den unteren Schwellwert fest:<br />
          Formel 1: <span class="box-noscroll"> <code>{Auslöser:N} > ({UntereSchwelle:N} + 2.0) /* obere Schwelle */</code> </span><br />
          Die beiden weiteren Formeln bleiben wie oben angegeben.
        </li>
      </ul>
      <h3 id="summenzaehler">Summenzähler</h3>
      <p>
        Die folgende Formel erhöht, beginnend bei <code>0</code>, mit jedem
        eintreffenden Telegramm am Eingang <code>Erhöhung</code> den Ausgang
        um den eingehenden Wert:<br />
        <span class="box-noscroll"> <code>{Neustart:B} ? 0 /* neu starten */ : (_previousOut1_ + {Erhöhung:I}) /* aufsummieren */</code> </span><br />
        Aufgrund des Bedingungsoperators gilt dies jedoch nur so lange,
        wie der Eingang <code>Neustart</code> den Wert <code>false</code> hat.
        Wenn und solange <code>Neustart</code> den Wert <code>true</code> hat,
        wird jede <code>Erhöhung</code> verworfen und der Ausgang wird (oder
        bleibt bei) <code>0</code>.
      </p>
      <p>
        Die angegebene Formel erzeugt am Ausgang eine Ganzzahl (z. B.
        INTEGER). Sie lässt sich leicht so abwandeln, dass sie
        Fließkommazahlen verarbeitet und ausgibt.
      </p>
      <h3 id="zustandsautomat">Zustandsautomat</h3>
      <p>
        Als Beispiel für einen einfachen Zustandsautomaten dient ein Auf-/Abwärtszähler
        mit unterer Grenze 0 und oberer Grenze 2. Das folgende Zustandsdiagramm
        zeigt, welche Zustände dieser Automat annehmen kann und welche Übergänge
        zwischen ihnen möglich sein sollen:<br />
      </p>
      <p>
        <img src="StateDiagram.png" alt="" class="example" />
      </p>
      <p>
        Um die Formeln übersichtlich zu halten, hat jeder Zustandsübergang seine
        eigene Formel, in der die Anfangsbedingung und der Zielzustand enthalten
        sind. Wichtig ist, dass immer nur <i>eine</i> der Anfangsbedingungen
        erfüllt ist. Dazu wertet die erste Formel aus, welche Eingänge aktuell
        einen Wert erhalten haben. Nur wenn ein Auf- oder Ab-Telegramm, aber
        kein kein Reset anliegt, lassen wir die Zustandsübergänge zum Auf- und
        Abwärtszählen zu:<br />
        Formel 1: <span class="box-noscroll"> <code>_isAbAufValueSet_ && !({Reset:B} && _isResetValueSet_)</code> </span><br />
        Die Zustandsübergänge zum Auf- und Abwärtszählen benötigen außerdem den
        aktuellen Zustand des Automaten, der zuletzt an Ausgang 8 ausgegeben
        worden ist:<br />
        Formel 2: <span class="box-noscroll"> <code>(!{AbAuf:B} && _out1_ && (_previousOut8_ == 1)) ? 0 : -1</code> </span><br />
        Formel 3: <span class="box-noscroll"> <code>(!{AbAuf:B} && _out1_ && (_previousOut8_ == 2)) ? 1 : -1</code> </span><br />
        Formel 4: <span class="box-noscroll"> <code>({AbAuf:B} && _out1_ && (_previousOut8_ == 0)) ? 1 : -1</code> </span><br />
        Formel 5: <span class="box-noscroll"> <code>({AbAuf:B} && _out1_ && (_previousOut8_ == 1)) ? 2 : -1</code> </span><br />
        Der Reset führt unabhängig vom aktuellen Zustand immer in den Zustand 0:<br />
        Formel 6: <span class="box-noscroll"> <code>({Reset:B} && _isResetValueSet_) ? 0 : -1</code> </span><br />
        Da die Formeln für alle <i>nicht</i> zutreffenden Zustandsübergänge -1
        ausgeben, führt der tatsächlich zutreffende Zustandsübergang zu dem
        Zustand, der sich aus dem Maximum der vorigen fünf Ergebnisse ergibt:<br />
        Formel 7: <span class="box-noscroll"> <code>MoreMath.Max(_out2_, _out3_, _out4_, _out5_, _out6_)</code> </span><br />
        Wenn dieses Maximum -1 ist, dann findet <i>gar kein</i> Zustandsübergang
        statt. In diesem Fall soll auch nichts ausgegeben werden:<br />
        Formel 8: <span class="box-noscroll"> <code>(_out7_ >= 0) ? (int?)_out7_ : null</code> </span>
      </p>
      <p>
        Der gesamte Zustandsautomat lässt sich so mit einem einzigen
        Formelberechnungs-Baustein realisieren, der hier mit beispielhaften
        Simulationsdaten gezeigt ist:<br />
        <img src="StateMachine.png" alt="" class="example" width="606" /><br />
        Zuletzt wurde eine 1 gleichzeitig an Ab/Auf und Reset gesendet. Da der
        Reset Priorität hat, wird das Auf-Telegramm verworfen. Der Ausgang steht
        deshalb wie gewünscht auf 0.
      </p>
      <p>
        Bei der Weiterverarbeitung des Ausgabewerts von Ausgang 8 ist zu beachten,
        dass der Startzustand immer 0 ist. Dieser wird aber beim Neustart des
        Logikmoduls nicht ausgegeben. Die Eingänge nachfolgender Logikbausteine
        müssen daher mit 0 vorbelegt sein.
      </p>
      <p>
        Nach dem gezeigten Prinzip lassen sich auch komplexere Zustandsautomaten
        realisieren.
      </p>
    </div>
  </section>
  <footer>
    <div id="footerHead">
      Recomedia Visu- &amp; Web-Logikbausteine &nbsp; <span style="color: #a0a0a0;">Hilfe</span>
    </div>
    <div id="footerNav">
      <img src="../icons/ExpressionCalculatorNode.png" alt="" />
      <span style="color: #a0a0a0;">&nbsp;Formelberechnung</span>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="StringFormatter.html"><img src="../icons/StringFormatterNode.png" alt="" /></a>
      &nbsp;<a href="StringFormatter.html">Textformatierer</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="XmlParser.html"><img src="../icons/XmlJsonParserNode.png" alt="" /></a>
      &nbsp;<a href="XmlParser.html">XML/JSON-Parser</a>
      <span style="float: right;">Weitere Logikbausteine sind in Planung.</span>
    </div>
  </footer>
</body>
</html>
