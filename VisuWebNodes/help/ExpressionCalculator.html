<!DOCTYPE HTML>
<html lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Recomedia Visu- &amp; Web-Logikbausteine - Hilfe - Formelberechnung</title>
  <link rel="StyleSheet" href="default.css" type="text/css" />
</head>

<body>
  <header>
    <span id="headBlack">Recomedia Visu- &amp; Web-Logikbausteine</span>
    <span id="headGray">Hilfe</span>
  </header>
  <section>
    <div class="contentholder">
      <div class="navlinks-top">
        <a href="#footerHead">↓ Andere Logikbausteine in diesem Paket</a>
        &nbsp; | &nbsp; <a href="Index.html">← Inhalt</a>
      </div>
      <h1>
        <img src="../icons/ExpressionCalculatorNode.png" alt="" />&nbsp;
        Formelberechnung
      </h1>
      <h2>Beschreibung</h2>
      <img src="ExpressionCalculator.png" class="description" />
      <p>
        Dieser Baustein errechnet aus einer oder mehreren mathematischen Formeln
        entsprechende Ausgabewerte. Die Formeln sind frei konfigurierbar. Sie
        können aus Konstanten, Platzhaltern für variable Eingangswerte,
        Rechenoperationen, Funktionsaufrufen und Kommentaren bestehen. Die
        Platzhalter bestimmen Anzahl, Namen und Port&shy;typen der Eingänge.
      </p>
      <p>
        Folgende Arten von Eingangs- und Ausgabewerten können verarbeitet werden:
      </p>
      <ul>
        <li>
          Wahrheitswerte (<tt>bool</tt>)
        </li>
        <li>
          Numerische Werte (Ganzzahlen <tt>byte</tt>, <tt>int</tt>, <tt>long</tt> und
          Fließkommazahlen <span class="manhyphens"><tt>double</tt></span>)
        </li>
        <li>
          Texte (<tt>string</tt>)
        </li>
      </ul>
      <p>
        In den Formeln stehen nicht nur die üblichen Rechenoperationen, sondern
        darüber hinaus Vieles aus dem
        <a href="https://docs.microsoft.com/de-de/dotnet/api/?view=netframework-4.0">.NET 4.0 API</a>
        zur Verfügung.
      </p>
      <h3>Implementierung und Lizenzen</h3>
      <p>
        Dieser Baustein würde eigentlich thematisch besser ins Paket "Recomedia
        Generische Logikbausteine" passen. Aus technischen Gründen &ndash; er
        nutzt dieselbe Platzhalter-Implementierung wie der
        <a href="StringFormatter.html">Textformatierer</a>
        &ndash; muss er aber in diesem Paket ausgeliefert werden.
      </p>
      <p>
        Die Implementierung verwendet den
        <a href="http://docs.go-mono.com/?link=M%3aMono.CSharp.Evaluator.Evaluate(System.String)">Mono.CSharp.Evaluator</a>-Service (Version 3.6.1). Dieser steht
        <a href="https://www.mono-project.com/docs/faq/licensing/">unter der MIT-Lizenz</a>
        kostenlos
        <a href="https://github.com/mono/mono/blob/master/mcs/mcs/eval.cs">mit Quelltext</a>
        zur Verfügung.
      </p>
      <h2 id="eingaenge">Eingänge</h2>
      <p>
        Solange keine gültige(n) <a href="#parameter">Formel</a>(n) festgelegt
        wurde(n), hat der Baustein keine Eingänge.
        <i><b>Eingänge werden nur durch gültige Platzhalter in den Formeln angelegt.</b></i>
        Die Reihenfolge der Eingänge ergibt sich &ndash; für jeden Porttyp
        getrennt &ndash; aus der Reihenfolge der entsprechenden
        <a href="#platzhalter">Platzhalter</a> in den Formeln.
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width: 180px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h3>Bezeichnung</h3>
          </th>
          <th>
            <h3>Porttyp</h3>
          </th>
          <th>
            <h3>Beschreibung</h3>
          </th>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Bool</p>
          </td>
          <td>
            <p>
              Werte für Wahrheitswert-Platzhalter
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Integer</p>
          </td>
          <td>
            <p>
              Werte für Ganzzahl-Platzhalter
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Number</p>
          </td>
          <td>
            <p>
              Werte für Fließkommazahl-Platzhalter (auch Prozentwerte)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>aus Platzhalter</i></p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>
              Werte für Text-Platzhalter
            </p>
          </td>
        </tr>
      </table>
      <h2>Ausgänge</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width: 180px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h3>Bezeichnung</h3>
          </th>
          <th>
            <h3>Porttyp</h3>
          </th>
          <th>
            <h3>Beschreibung</h3>
          </th>
        </tr>
        <tr>
          <td>
            <p>Ausgang 1<br />..<br />Ausgang <i>n</i></p>
          </td>
          <td>
            <p>je nach entsprechen-<br />dem Parameter<br /><a href="#parameter">Typ des Ausgangs</a></p>
          </td>
          <td>
            <p>
              Alle Ausgänge geben erst dann Werte aus, wenn <i>alle</i> Eingangswerte
              vorliegen. Wenn mehrere Formeln und Ausgänge verwendet werden, gilt dies
              auch für Formeln, in denen die fehlenden Werte gar nicht vorkommen.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                Eingangswerte, die weder abgefragt werden können noch zyklisch senden,
                sollten deshalb einen Vorgabewert haben.
              </li>
              <li>
                Werden unbenutzte Ausgänge nicht versteckt, so steht jeder Ausgang
                direkt neben dem <a href="#parameter">Formelparameter</a>, der ihn
                berechnet.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>Laufzeitfehler</p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>
              Einige Fehler, die in den Formeln auftreten können, werden bereits
              bei der Validierung festgestellt und im GPA ausgegeben.
            </p>
            <p>
              Viele Fehler lassen sich aber erst beim Berechnen der Ausgangswerte
              &ndash; also zur Laufzeit des Bausteins in der GPA-Simulation oder
              nach der Inbetriebnahme auf dem Zielgerät &ndash; feststellen. Solche
              Fehler werden an diesem Ausgang als Texte gemeldet.
            </p>
            <p>
              Beispiel: Der Fehler<br />
              <tt>&nbsp;&nbsp;&nbsp;...: error CS1026: Unexpected symbol ',', expecting ')'</tt><br />
              weist sehr wahrscheinlich darauf hin, dass in einer Fließkommazahl  Komma
              (<b>,</b>) statt Punkt (<b>.</b>) vor den Nach&shy;komma&shy;stellen steht.
              Anstelle von <tt>...</tt> steht, wo der Fehler zu suchen ist: In welcher
              Formel, in welcher Zeile (meist 1) und Zeichenposition.
            </p>
            <p>
              Hinweis: Die meisten Laufzeit-Fehlermeldungen werden &ndash; wie
              im Beispiel &ndash; in englischer Sprache ausgegeben.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="parameter">Parameter</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 115px">
          <col style="width:  70px">
          <col style="width: 110px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h3>Bezeichnung</h3>
          </th>
          <th>
            <h3>Porttyp</h3>
          </th>
          <th>
            <h3>Als Eingang zuschaltbar?</h3>
          </th>
          <th>
            <h3>Beschreibung</h3>
          </th>
        </tr>
        <tr>
          <td>
            <p>Anzahl der<br />Ausgänge<br />und Formeln</p>
          </td>
          <td>
            <p>Integer</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Dieser Parameter legt die Anzahl der Ausgänge des Bausteins im
              Bereich 1..50 fest. Da jeder Ausgang seine eigene Formel hat,
              legt dies auch die Anzahl der Formelparameter fest.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>Typ des<br />Ausgangs 1<br />..<br />Typ des<br />Ausgangs <i>n</i></p>
          </td>
          <td>
            <p>Auswahl</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Diese Parameter legen fest, welchen Porttyp der entsprechende
              Ausgangswert jeweils haben soll. Möglich sind die folgenden
              Typen (mit ihren C#-Entsprechungen):
              <dl>
                <dt>NUMBER</dt>
                <dd>Fließkommazahl (<tt>double</tt>)</dd>
                <dt>INT64</dt>
                <dd>64-Bit-Ganzzahl mit Vorzeichen (<tt>long</tt>)</dd>
                <dt>INTEGER</dt>
                <dd>32-Bit-Ganzzahl mit Vorzeichen (<tt>int</tt>)</dd>
                <dt>BYTE</dt>
                <dd>8-Bit-Ganzzahl ohne Vorzeichen (<tt>byte</tt>)</dd>
                <dt>BOOL</dt>
                <dd>Wahrheitswert (<tt>bool</tt>)</dd>
                <dt>STRING</dt>
                <dd>Text (<tt>string</tt>)</dd>
              </dl>
            </p>
            <p>
              In Klammern ist jeweils der C#-Typ angegeben, wie er in
              <a href="#operatoren">Typumwandlungsoperatoren</a>
              verwendet werden kann. Das Ergebnis der Formelauswertung muss
              sich in diesen Typ umwandeln lassen, sonst kann der Ausgang
              nicht gesetzt werden und es kommt zu einem Laufzeitfehler.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>Formel 1<br />..<br />Formel <i>n</i></p>
          </td>
          <td>
            <p>Text</p>
          </td>
          <td>
            <p>nein</p>
          </td>
          <td>
            <p>
              Diese Parameter legen fest, wie die jeweiligen Ausgangswerte
              zu berechnen sind. Darin können <a href="#variablen">Variablen</a>,
              <a href="#konstanten">Konstanten</a>, <a href="#operatoren">Operatoren</a>,
              mathematische und andere <a href="#funktionen">Funktionen</a> und
              <a href="#kommentare">Kommentare</a> vorkommen. In den nächsten
              Kapiteln sind alle diese detailliert beschrieben.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="variablen">Ausgangswerte als Variablen</h2>
      <p>
        Aktuelle und vorherige Ausgabewerte können in den Formeln als Variablen
        verwendet werden. Diese Variablen haben die Namen <tt>_out1_</tt> ..
        <tt>_out49_</tt> (für aktuelle Werte) bzw. <tt>_previousOut1_</tt> ..
        <tt>_previousOut50_</tt> (für vorherige Werte). Sie dürfen überall stehen,
        wo auch eine Konstante des gleichen Typs stehen dürfte.
      </p>
      <p>
        <em>Aktuelle</em> Werte sind solche, die seit der letzten Änderung
        eines Eingangs neu berechnet worden sind. Durch ihre Verwendung
        lassen sich große Formeln (oder solche, in denen Zwischenergebnisse
        mehrfach verwendet werden) in übersichtliche Teile zerlegen. Wird ein
        Zwischenergebnis nur in den weiteren Formeln (also nicht außerhalb des
        Bausteins) benötigt, so bleibt der entsprechende Ausgang unbelegt.
        Das Beispiel
        <a href="#hysteresebeispiel">Verbesserter Schwellwert mit Hysterese</a>
        benutzt einen solchen Formelsatz.
      </p>
      <p>
        <em>Vorherige</em> Werte sind solche, die <em>zuletzt vor</em> der
        aktuellen Änderung eines Eingangs auf die Ausgänge gegeben worden
        sind. Dabei ist zu beachten, das <em>jede</em> Änderung eines Eingangs
        <em>alle</em> Formeln neu berechnet (auch solche die den geänderten
        Eingangswert gar nicht verwenden). Damit lassen sich einfache
        <a href="https://de.wikipedia.org/wiki/Endlicher_Automat">Zustandsautomaten</a>
        realisieren. Das Beispiel <a href="#summenzaehler">Summenzähler</a>
        zeigt eine einfache und nützliche Anwendung.
      </p>
      <p>
        Folgende Werte können in einer Formel verwendet werden, deren Nummer <i>n</i>
        sei:
      </p>
      <ul>
        <li>
          <em>Aktuelle</em> Werte können nur aus Formeln mit <em>niedrigeren</em>
          Nummern (<tt>_out1_</tt> .. <tt>_out&lt;<i>n</i>-1&gt;_</tt>) verwendet
          werden. Sie stehen also nur zur Verfügung, wenn es mehrere Formeln gibt.
          Dies vermeidet zyklische Abhängigkeiten.
        </li>
        <li>
          <em>Vorherige</em> Werte können aus <em>allen</em> Formeln verwendet
          werden. Das schließt die eigene und höhere Nummern
          (<tt>_previousOut&lt;<i>n</i>&gt;_</tt> ..) ein. (Zu zyklischen
          Abhängigkeiten führt das nicht, weil diese Werte erst wieder vor den
          Berechnungen für die <em>nächste</em> Änderung aktualisiert werden.)
        </li>
      </ul>
      <p>
        Nach einer Inbetriebnahme oder einem Neustart des Logikmoduls gibt es
        zunächst keine Werte aus vorherigen Berechnungen. Je nach Typ werden
        bis zum ersten Setzen eines Ausgangs <i>n</i> die folgenden Werte für
        <tt>_previousOut&lt;<i>n</i>&gt;_</tt> verwendet:
      </p>
      <dl>
        <dt>NUMBER</dt>
        <dd><tt>0.0</tt></dd>
        <dt>INT64, INTEGER, BYTE</dt>
        <dd><tt>0</tt></dd>
        <dt>BOOL</dt>
        <dd><tt>false</tt></dd>
        <dt>STRING</dt>
        <dd><tt>""</tt> (Leerstring)</dd>
      </dl>
      <h2 id="platzhalter">Platzhalter für Variablen</h2>
      <p>
        Platzhalter in den Formeln dienen dazu, variable Eingangswerte in den
        Berechnungen zu verwenden. Sie dürfen überall stehen, wo auch eine
        Konstante des gleichen Typs stehen dürfte.
      </p>
      <p>
        Es gibt zwei grundlegende Arten von Platzhaltern:
      </p>
      <ul>
        <li>
          <b>Definition</b> &ndash; definiert erstmals einen Eingang
          mit Namen und Typ und hat die folgende Form:<br />
          &nbsp;&nbsp;&nbsp;&nbsp;<tt>{</tt><i>Eingangsname</i><tt>:</tt><i>T</i><tt>}</tt>
        </li>
        <li>
          <b>Referenz</b> &ndash; bezieht sich auf einen vorher definierten
          Eingang. Sie folgt der gleichen Form, wobei <tt>:</tt><i>T</i>
          weg gelassen werden darf.
        </li>
      </ul>
      <p>
        <i>Eingangsname</i> wird als <b>Bezeichnung des Baustein-Eingangs</b>
        verwendet. Definitionen legen Eingänge an und setzen deren Werte
        in die Formel ein. Referenzen beziehen sich auf einen vorher
        definierten Namen und verwenden den Wert des entsprechenden Eingangs
        erneut. Sie dürfen sich auch auf Namen beziehen, die in einer anderen
        Formel mit einer niedrigeren Nummer definiert worden sind. Referenzen
        dürfen keinen von der Definition abweichenden Datentyp festlegen.
      </p>
      <p>
        <i>Eingangsname</i> muss mit einem Buchstaben beginnen. Weiter kann
        er auch Ziffern (0..9) und Unterstriche (<tt>_</tt>) enthalten.
        Leerzeichen und andere Sonderzeichen sind nicht zulässig. Leerzeichen
        am Anfang oder am Ende sind erlaubt, werden aber nicht in den Namen
        übernommen.
      </p>
      <p>
        <i>T</i> ist ein Buchstabe, der den <b>Datentyp</b> des Eingangs
        festlegt.<br />
        Folgende Buchstaben &ndash; Groß- und Kleinbuchstaben haben gleiche
        Bedeutung &ndash; sind möglich:
      </p>
      <dl>
        <dt><tt>B</tt></dt>
        <dd>
          Wahrheitswert (<tt>bool</tt>) &ndash; Mögliche Werte: <tt>true</tt>, <tt>false</tt>
        </dd>
        <dt><tt>I</tt></dt>
        <dd>
          Ganzzahl (<tt>int</tt>) &ndash; Wertebereich -2 147 483 648 .. 2 147 483 647
        </dd>
        <dt><tt>F</tt>, <tt>N</tt>, <tt>G</tt> oder<sup> </sup><tt>P</tt></dt>
        <dd>
          Fließkommazahl (<tt>double</tt>) &ndash; Wertebereich etwa
          -1.7 × 10<sup>308</sup> .. 1.7 × 10<sup>308</sup>&nbsp;mit
          einer Genauigkeit von mindestens 15 geltenden Ziffern
        </dd>
        <dt><tt>S</tt></dt>
        <dd>
          Text (<tt>string</tt>) &ndash; ASCII-, ISO-8859-1- oder Unicode-Text
        </dd>
      </dl>
      <p>
        <b>Hinweis:</b><br />
        Bei numerischen Berechnungen sind die angegebenen Wertebereiche zu beachten.
        Werden sie in irgend einem Teil der Formel überschritten, kommt es zu
        falschen Ergebnissen.
      </p>
      <h2 id="konstanten">Literale Konstanten in Formeln</h2>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 100px">
          <col style="width: 100px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h3>Konstante</h3>
          </th>
          <th>
            <h3>Datentyp</h3>
          </th>
          <th>
            <h3>Beschreibung</h3>
          </th>
        </tr>
        <tr>
          <td>
            <p><i>Zahl</i></p>
          </td>
          <td>
            <p><tt>byte<br />integer<br />long<br />double</tt></p>
          </td>
          <td>
            <p>
              Zahlen, die ohne Dezimaltrennzeichen angegeben werden, also nur aus
              Ziffern bestehen, sind Ganzzahlen (<tt>int</tt>). Dies ist insbesondere
              beim Dividieren zu beachten (siehe Divisions-Operator).
            </p>
            <p>
              Ganzzahlen können auch in hexadezimaler Schreibweise angegeben werden,
              indem man ihnen <tt>0x</tt>... voran stellt. Weitere Details finden sich
              im Abschnitt
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#integer-literals">Ganzzahlenliterale</a>
              der C#-Sprachreferenz von Microsoft.
            </p>
            <p>
              Fließkommazahlen (<tt>double</tt>) können auch in Exponentialschreibweise
              angegeben werden. Z. B. bedeutet <tt>1.2E6</tt> dasselbe wie
              <tt>1200000.0</tt> und <tt>-3.45E-3</tt> dasselbe wie <tt>-0.00345</tt>.
              Als Dezimaltrenzeichen für Fließkomazahlen ist in Formeln &ndash;
              anders als in sonstigen Eingabefeldern &ndash; immer Punkt (<b>.</b>)
              zu verwenden. Gruppentrennzeichen (Tausendertrennzeichen) sind nicht
              zulässig.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>true<br />false</tt></p>
          </td>
          <td>
            <p><tt>bool</tt></p>
          </td>
          <td>
            <p>Logische Wahrheitswerte.</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>Math.PI</tt></p>
          </td>
          <td>
            <p><tt>double</tt></p>
          </td>
          <td>
            <p>
              Die Kreiszahl
              (<font style="font-family: 'Times New Roman', Times, serif; font-size:larger;">&pi;</font>
              = 3.141...)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>Math.E</tt></p>
          </td>
          <td>
            <p><tt>double</tt></p>
          </td>
          <td>
            <p>
              Die Eulersche Zahl
              (<font style="font-family: 'Times New Roman', Times, serif; font-size:larger;">e</font>
              = 2.718...)
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>DateTime.<br />&nbsp;&nbsp;Today<br />&nbsp;&nbsp;Now</tt></p>
          </td>
          <td>
            <p><tt>DateTime</tt></p>
          </td>
          <td>
            <p>
              Nicht wirklich Konstanten, da die Werte vom Zeitpunkt des Aufrufs abhängen:<br />
              Aktuelles Datum (<tt>Today</tt> mit Uhrzeit 0:00 Uhr; <tt>Now</tt> mit aktueller
              Uhrzeit)
            </p>
            <p>
              Hinweis: Objekte vom Typ <tt>DateTime</tt> sind nicht direkt als Ausgabewerte
              verwendbar. Nützlich sind sie für Berechnungen mit Daten und Uhrzeiten, die
              anders nicht ohne Weiteres möglich wären. Sie lassen sich auch in gültige
              Ausgabetypen (Zahlen oder Texte) umwandeln. Siehe dazu die
              <a href="https://docs.microsoft.com/de-de/dotnet/api/system.datetime?view=netframework-4.0">Dokumentation der <tt>DateTime</tt>-Klasse</a>
              und das <a href="#feiertagbeispiel">Anwendungsbeispiel "Feiertag"</a>.
              Korrekt formatierte Texte kann der Gira-Typumwandler auch wieder
              in DateTime-Datenpunkte umwandeln.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>"</tt><i>Text</i><tt>"</tt></p>
          </td>
          <td>
            <p><tt>string</tt></p>
          </td>
          <td>
            <p>
              Literale ASCII- oder Unicode-Text-Konstante
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>null</tt></p>
          </td>
          <td>
            <p>&mdash;</p>
          </td>
          <td>
            <p>
              Das typlose "nichts" kann überall stehen wo ein beliebiger
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/builtin-types/nullable-value-types">auf NULL festlegbarer Typ</a>
              zulässig ist. Nützlich ist das vor allem, wenn man in einem
              Zweig eines Bedingungsoperators <em>keinen</em> Wert an einen
              Ausgang senden möchte. Für Ausgänge vom Typ STRING funktioniert
              das direkt. Für alle anderen Ausgangstypen muss man im anderen
              Zweig des Bedingungsoperators explizit die auf NULL festlegbare
              Variante des Ausgabetyps verwenden. Das Beispiel
              <a href="#hysteresebeispiel">Verbesserter Schwellwert mit Hysterese</a>
              zeigt, wie man das mit Typumwandlungs-Operatoren erreicht.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="operatoren">Operatoren</h2>
      Alle
      <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/">C#-Operatoren</a>,
      die sich auf verfügbare Datentypen anwenden lassen, sind zulässig.
      Die wichtigsten davon sind:
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width:  60px">
          <col style="width:  90px">
          <col style="width: 115px">
          <col style="width: 115px">
          <col style="width: 100px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h3>Rang-folge</h3>
          </th>
          <th>
            <h3>Assozia-tivität</h3>
          </th>
          <th>
            <h3>Operator</h3>
          </th>
          <th>
            <h3>Bezeichnung</h3>
          </th>
          <th>
            <h3>Datentypen</h3>
          </th>
          <th>
            <h3>Beschreibung</h3>
          </th>
        </tr>
        <tr>
          <td rowspan="2">
            <p style="margin-top:42px;">&nbsp;&nbsp;1</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:34px;">Von rechts nach links </p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>+ &nbsp; -</tt></p>
          </td>
          <td>
            <p style="margin-top:16px;">Vorzeichen</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p>
              Kein Vorzeichen oder <tt>+</tt> wertet den nachfolgenden Ausdruck<br />
              positiv, <tt>-</tt> negativ.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;"><tt>!</tt></p>
          </td>
          <td>
            <p style="margin-top:16px;">NICHT</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>bool</tt></p>
          </td>
          <td>
            <p>
              Invertiert den nachfolgenden booleschen Ausdruck<br />(<tt>true</tt>
              &rarr; <tt>false</tt>; <tt>false</tt> &rarr; <tt>true</tt>).
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;2</p>
          </td>
          <td>
            <p>Von rechts nach links</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>(</tt><i>T</i><tt>)</tt></p>
          </td>
          <td>
            <p>Typumwand-<br />lung (Cast)</p>
          </td>
          <td>
            <p><i>alle</i> &rarr; <i>T</i></p>
          </td>
          <td>
            <p>
              Erzwingt eine Typumwandlung des nachfolgenden Ausdrucks<br />auf
              <i>T</i>. Für <i>T</i> können &ndash; über die an Ein- und Ausgängen
              möglichen Typen hinaus &ndash; auch viele andere
              <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/keywords/value-types-table">Werttypen von C#</a>
              stehen.
            </p>
          </td>
        </tr>
        <tr>
          <td rowspan="2">
            <p style="margin-top:130px;">&nbsp;&nbsp;3</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:122px;">Von links nach rechts</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>* &nbsp; /</tt></p>
          </td>
          <td>
            <p>Punkt-Grund-rechenarten</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p>
              Hinweise:
            </p>
            <p>
              Bei der Division von Ganzzahlen wird das Ergebnis nicht
              gerundet, sondern eventuelle Nachkommastellen einfach
              abgeschnitten. Man vergleiche die folgenden Beispiele:
            </p>
            <ul>
              <li><tt>-3 / 2</tt> &nbsp; &rarr; &nbsp; <tt>-1</tt></li>
              <li><tt>-3.0 / 2</tt> &nbsp; &rarr; &nbsp; <tt>-1.5</tt></li>
              <li>
                <tt>Math.Round(((double)-3) / 2)</tt> &nbsp; &rarr;
                &nbsp; <tt>-2.0</tt>
              </li>
            </ul>
            <p>
              Um Fließkommazahlen auf Ganzzahlen zu runden, braucht man
              übrigens keine Formelberechnung, das kann schon der
              Typkonverter von Gira.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;"><tt>%</tt></p>
          </td>
          <td>
            <p style="margin-top:16px;">Divisionsrest</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>int</tt></p>
          </td>
          <td>
            <p>
              Ergibt den Divisionsrest einer ganzzahlingen Division.<br />
              Beispiel: <tt>5 % 3</tt> &rarr; <tt>2</tt>.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;4</p>
          </td>
          <td>
            <p>Von links nach rechts</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>+ &nbsp; -</tt></p>
          </td>
          <td>
            <p>Strich-Grund-rechenarten</p>
          </td>
          <td>
            <p><i>alle<br />Zahltypen</i></p>
          </td>
          <td>
            <p style="margin-top:16px;">
              <tt>+</tt> dient auch zur Verkettung von Texten (<tt>string</tt>).
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;5</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">Von links nach rechts</p>
          </td>
          <td>
            <p><tt>< &nbsp;> &nbsp;<= &nbsp;>=</tt></p>
          </td>
          <td>
            <p>Relational</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">
              <i>alle<br />Zahltypen</i><br />&rarr; <tt>bool</tt>
            </p>
          </td>
          <td rowspan="2">
            <p style="margin-top:25px;">
              Vergleicht zwei Werte und ergibt <tt>true</tt>, wenn der
              Vergleichsoperator zutrifft, sonst <tt>false</tt>.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">&nbsp;&nbsp;6</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>== &nbsp; !=</tt></p>
          </td>
          <td>
            <p>Gleichheit,<br />Ungleichheit</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;7</p>
          </td>
          <td rowspan="3">
            <p style="margin-top:36px;">
              Von links nach rechts
            </p>
          </td>
          <td>
            <p><tt>&amp;</tt></p>
          </td>
          <td>
            <p>UND</p>
          </td>
          <td rowspan="3">
            <p style="margin-top:44px;"><tt>bool</tt></p>
          </td>
          <td rowspan="3">
            <p style="margin-top:11px;">
              Logische Operatoren mit vollständiger Auswertung.
            </p>
            <p>
              Hinweis:<br />
              Der sonst übliche Operator <tt>x^y</tt> (x<sup>y</sup>) für
              Zahlen steht nicht zur Verfügung. Man verwendet dazu die
              <a href="#funktionen">Funktion</a> <tt>Math.Pow</tt>.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;8</p>
          </td>
          <td>
            <p><tt>^</tt></p>
          </td>
          <td>
            <p>Exklusiv-ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&nbsp;&nbsp;9</p>
          </td>
          <td>
            <p><tt>|</tt></p>
          </td>
          <td>
            <p>ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>10</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">
              Von links nach rechts
            </p>
          </td>
          <td>
            <p><tt>&amp;&amp;</tt></p>
          </td>
          <td>
            <p>UND</p>
          </td>
          <td rowspan="2">
            <p style="margin-top:26px;"><tt>bool</tt></p>
          </td>
          <td rowspan="2">
            <p style="margin-top:18px;">
              Logische Operatoren mit bedingter Auswertung, d. h. die Auswertung erfolgt nur
              so weit, bis das Ergebnis feststeht.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>11</p>
          </td>
          <td>
            <p><tt>||</tt></p>
          </td>
          <td>
            <p>ODER</p>
          </td>
        </tr>
        <tr>
          <td>
            <p style="margin-top:16px;">12</p>
          </td>
          <td>
            <p>Von rechts nach links</p>
          </td>
          <td>
            <p style="margin-top:16px;"><i>b</i><tt> ? </tt><i>x</i><tt> : </tt><i>y</i></p>
          </td>
          <td>
            <p style="margin-top:16px;">Bedingung</p>
          </td>
          <td>
            <p style="margin-top:16px;"><tt>bool</tt> &rarr; <i>alle</i></p>
          </td>
          <td>
            <p style="margin-top:16px;">Gibt <i>x</i> zurück, wenn <i>b</i> <tt>true</tt> ist, sonst <i>y</i>.</p>
          </td>
        </tr>
      </table>
      <p>
        Die ersten beiden Spalten der Tabelle geben an, wie nicht geklammerte
        Ausdrücke ausgewertet werden. Darin ist z. B. auch die bekannte Regel
        "Punkt vor Strich" enthalten: <tt>*</tt> und <tt>/</tt> werden vor
        <tt>+</tt> und <tt>-</tt> ausgewertet. Geklammerte Ausdrücke
        <tt>(</tt>...<tt>)</tt> werden "von innen nach außen" berechnet.
        Weitere Angaben dazu finden sich im Abschnitt
        <a href="https://docs.microsoft.com/de-de/dotnet/csharp/language-reference/operators/#operator-precedence">Operatorrangfolge</a>
        der C#-Sprachreferenz.
      </p>
      <h2 id="funktionen">Funktionen</h2>
      <p>
        Soweit ihre Parameter- und Rückgabetypen sinnvoll verwendbar sind,
        stehen viele Klassen des
        <a href="https://docs.microsoft.com/de-de/dotnet/api/?view=netframework-4.0">gut und in deutscher Sprache dokumentierten .NET 4.0 APIs</a>
        mit ihren Funktionen zur Verfügung. Dieses Kapitel geht nur auf
        einige besonders nützliche Bereiche und Besonderheiten ein.
      </p>
      <p>
        Neben dem .NET-Framework stehen eigene Erweiterungen vor allem zur
        <a href="#light">Beleuchtungs-</a> und <a href="#HLK">Klimatechnik</a>
        zur Verfügung.
      </p>
      <h3>Mathematische Funktionen: Math-Bibliothek und Winkelfunktionen</h3>
      <p>
        Die meisten
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.math?view=netframework-4.0#methoden"><b>Math</b>-Methoden des .NET-4.0-Standards</a>
        können in den Formeln verwendet werden.
      </p>
      <p>
        Beispiel: <tt>Math.Pow({x:N}, {y:N})</tt> berechnet aus den beiden Eingangswerten
        x und y deren Potenz x<sup>y</sup>.
      </p>
      <p>
        Die trigonometrischen Funktionen der <tt>Math</tt>-Bibliothek verwenden
        und liefern alle Winkelangaben im Bogenmaß. Zur Umrechnung zwischen Grad-
        und Bogenmaß stehen die folgenden beiden Funktionen der
        <tt>Angle</tt>-Erweiterung zur Verfügung:
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h4>Funktion</h4>
          </th>
          <th>
            <h4>Datentyp</h4>
          </th>
          <th>
            <h4>Beschreibung</h4>
          </th>
        </tr>
        <tr>
          <td>
            <p><tt>Angle.Deg(</tt><i>rad</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>double</tt></p>
          </td>
          <td>
            <p>Rechnet den im Bogenmaß gegebenen Winkel <i>rad</i> ins Gradmaß um.</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>Angle.Rad(</tt><i>deg</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>double</tt></p>
          </td>
          <td>
            <p>Rechnet den im Gradmaß gegebenen Winkel <i>deg</i> ins Bogenmaß um.</p>
          </td>
        </tr>
      </table>
      <p>
        Mit den <tt>Math</tt>- und <tt>Angle</tt>-Funktionen sind trigonometrische,
        logarithmische und andere gebräuchliche mathematische Anwendungen abgedeckt.
      </p>
      <h3>Stringfunktionen</h3>
      <p>
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.double.tostring?view=netframework-4.0">ToString</a>
        mit seinen verschiedenen Varianten für alle numerischen Typen erlaubt die
        sehr flexible Formatierung von Zahlen als Texte. Auch können fast alle
        <a href="https://docs.microsoft.com/de-de/dotnet/api/system.string?view=netframework-4.0#methoden"><b>String</b>-Methoden des .NET-4.0-Standards</a>
        verwendet werden.
      </p>
      <p>
        Beispiel Textersetzung: Mit
        <span class="box-noscroll"> {text:S}.Replace("alt","neu") </span>
        wird der Eingangstext: "<i>Alles alt macht der Mai</i>" am Ausgang zu
        "<i>Alles neu macht der Mai</i>".
      </p>
      <h3 id="light">Funktionen zur Beleuchtungssteuerung</h3>
      <p>
        Die Funktionen der <tt>Light</tt>-Erweiterung rechnen gängige Größen
        der Beleuchtungstechnik um:
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h4>Funktion</h4>
          </th>
          <th>
            <h4>Datentyp</h4>
          </th>
          <th>
            <h4>Beschreibung</h4>
          </th>
        </tr>
        <tr>
          <td>
            <p><tt>Light.HSV(</tt><i>h</i><tt>, </tt><i>s</i><tt>, </tt><i>v</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>byte</tt> &rarr; <tt>int</tt></p>
          </td>
          <td>
            <p>
              Rechnet die als einzelne 8-Bit-Werte (DPT 5.x) gegebenen Farbgrößen für
              Farbwert (<i>h</i>ue), Farbsättigung (<i>s</i>aturation) und Hellwert
              (<i>v</i>alue) in eine kombinierte HSV-Größe (3 Bytes, ähnlich zu DPT
              232.600) um.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                Da Byte-Eingänge nicht vorgesehen sind, muss der Typumwandlungsoperator
                verwendet werden, um Integer-Eingänge als byte-Parameter verwenden zu
                können:
                <div class="box-noscroll" style="width: 565px;"> <tt>Light.HSV((byte){h:I}, (byte){s:I}, (byte){v:I})</tt></div>
              </li>
              <li>
                Für Integer-Werte außerhalb des Wertebereichs 0..255 führt dies zu
                unerwünschtem Verhalten. Es ist also sicher zu stellen, dass die
                Integer-Werte im gültigen Wertebereich bleiben. Dies ist z. B. der
                Fall, wenn sie aus DPT-5.x-Eingängen &ndash; oder ganz allgemein aus
                Bausteinen mit Byte-Ausgängen &ndash; stammen.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <tt>Light.HSVToH(</tt><i>hsv</i><tt>)</tt>
              <tt>Light.HSVToS(</tt><i>hsv</i><tt>)</tt>
              <tt>Light.HSVToV(</tt><i>hsv</i><tt>)</tt>
            </p>
          </td>
          <td>
            <p><tt>int</tt> &rarr; <tt>byte</tt></p>
          </td>
          <td>
            <p>
              Extrahiert aus der gegebenen kombinierten HSV-Größe <i>hsv</i> (3 Bytes,
              ähnlich zu DPT 232.600) die einzelnen 8-Bit-Farbgrößen (DPT 5.x) für
              Farbwert (<b>H</b>ue), Farbsättigung (<b>S</b>aturation) oder Hellwert
              (<b>V</b>alue).
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>Light.RGB(</tt><i>r</i><tt>, </tt><i>g</i><tt>, </tt><i>b</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>byte</tt> &rarr; <tt>int</tt></p>
          </td>
          <td>
            <p>
              Rechnet die als einzelne 8-Bit-Werte (DPT 5.x) gegebenen Farbintensitäten
              für <i>r</i>ot, <i>g</i>rün und <i>b</i>lau in eine kombinierte RGB-Größe
              (3 Bytes, DPT 232.600) um.
            </p>
            <p>
              Die bereits oben zu <tt>byte</tt>-Parametern gegebenen Hinweise gelten
              entsprechend.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <tt>Light.RGBToR(</tt><i>rgb</i><tt>)</tt>
              <tt>Light.RGBToG(</tt><i>rgb</i><tt>)</tt>
              <tt>Light.RGBToB(</tt><i>rgb</i><tt>)</tt>
            </p>
          </td>
          <td>
            <p><tt>int</tt> &rarr; <tt>byte</tt></p>
          </td>
          <td>
            <p>
              Extrahiert aus der gegebenen kombinierten RGB-Größe <i>rgb</i> (3 Bytes,
              DPT 232.600) die einzelnen 8-Bit-Farbintensitäten (DPT 5.x) für
              <b>R</b>ot, <b>G</b>rün oder <b>B</b>lau.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <tt>Light.RGBW(</tt><i>rgb</i><tt>)</tt>
              <tt>Light.RGBW(</tt><i>r</i><tt>, </tt><i>g</i><tt>, </tt><i>b</i><tt>)</tt>
            </p>
          </td>
          <td>
            <p><tt>int</tt> &rarr; <tt>long</tt><br /><tt>byte</tt> &rarr; <tt>long</tt></p>
          </td>
          <td>
            <p>
              Rechnet die gegebene RGB-Größe &ndash; wahlweise einzelne 8-Bit-Werte (DPT 5.x)
              oder 3 Bytes kombiniert (DPT 232.600) &ndash; in eine kombinierte RGBW-Größe
              (6 bytes, DPT 251.600) um. Die Umrechnung extrahiert die gemeinsame Helligkeit
              aller Farben in einen entsprechenden Wert für <i>w</i>eiß. Die Farbintensitäten
              für <i>r</i>ot, <i>g</i>rün und <i>b</i>lau werden so weit reduziert, dass
              mindestens eine dieser Farben ganz weg fällt.
            </p>
            <p>
              Alle vier Werte im erzeugten DPT 251.600 sind gültig (und auch so markiert).
              Die bereits oben zu <tt>byte</tt>-Parametern gegebenen Hinweise gelten
              entsprechend.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p><tt>Light.RGBW(</tt><i>r</i><tt>, </tt><i>g</i><tt>, </tt><i>b</i><tt>, </tt><i>w</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>int</tt> &rarr; <tt>long</tt></p>
          </td>
          <td>
            <p>
              Rechnet die gegebenen Farbintensitäten für <i>r</i>ot, <i>g</i>rün, <i>b</i>lau
              und <i>w</i>eiß in eine kombinierte RGBW-Größe (6 bytes, DPT 251.600) um. Gültige
              Intensitäten liegen im Wertebereich 0..255. Werte außerhalb dieses Bereichs werden
              als 0 übernommen und ungültig markiert.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <tt>Light.RGBWToR(</tt><i>rgbw</i><tt>)</tt>
              <tt>Light.RGBWToG(</tt><i>rgbw</i><tt>)</tt>
              <tt>Light.RGBWToB(</tt><i>rgbw</i><tt>)</tt>
              <tt>Light.RGBWToW(</tt><i>rgbw</i><tt>)</tt>
            </p>
          </td>
          <td>
            <p><tt>long</tt> &rarr; <tt>int</tt></p>
          </td>
          <td>
            <p>
              Extrahiert aus der kombinierten RGBW-Größe <i>rgbw</i> (6 bytes, DPT 251.600)
              gültige Intensitäten für <b>R</b>ot, <b>G</b>rün, <b>B</b>lau oder <B>W</B>eiß
              im 8-Bit-Wertebereich 0..255. Als ungültig markierte Intensitäten werden mit
              dem Wert -1 zurück gegeben.
            </p>
            <p>
              Hinweise:
            </p>
            <ul>
              <li>
                DPT 251.600 hat 6 Bytes, von denen 36 Bits verwendet werden. Da
                Ganzzahl-Eingänge mit dem benötigten Wertebereich nicht zur
                Verfügung stehen, muss ein Fließkommazahl-Eingang und ein
                Typumwandlungsoperator verwendet werden; z. B.:
                <div class="box-noscroll" style="width: 565px;"> <tt>RGBWToB((long){r:N})</tt></div>
              </li>
              <li>
                Wenn im Eingabewert Intensitäten als ungültig markiert sein können, dann
                dürfen die Ausgabewerte nicht ohne Weiteres einem 8-Bit-Objekt (DPT 5.x)
                zugewiesen werden. Vielmehr ist der Ausgabewert -1 gesondert zu behandeln.
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <p>
              <tt>Light.RGBToHSV(</tt><i>r</i><tt>, </tt><i>g</i><tt>, </tt><i>b</i><tt>)</tt>
              <tt>Light.RGBToHSV(</tt><i>rgb</i><tt>)</tt>
              <tt>Light.HSVToRGB(</tt><i>h</i><tt>, </tt><i>s</i><tt>, </tt><i>v</i><tt>)</tt>
              <tt>Light.HSVToRGB(</tt><i>hsv</i><tt>)</tt>
            </p>
          </td>
          <td>
            <p>
              <tt>byte</tt> &rarr; <tt>int<br />int</tt> &rarr; <tt>int</tt><br />
              <tt>byte</tt> &rarr; <tt>int<br />int</tt> &rarr; <tt>int</tt>
            </p>
          </td>
          <td>
            <p>
              Rechnet Farbangaben zwischen dem RGB-Farbraum und dem HSV-Farbraum um.
            </p>
            <p>
              Die bereits oben zu <tt>byte</tt>-Parametern und DPT 232.600 gegebenen
              Hinweise gelten <span class="manhyphens">entsprechend</span>.
            </p>
          </td>
        </tr>
      </table>
      <p>
        Mit diesen Funktionen lässt sich z. B. aus einem HSV-Controller eine
        RGBW-LED-Leiste ansteuern.
      </p>
      <h3 id="HLK">Funktionen für die Heizungs-, Lüftungs- und Klimatechnik (HLK)</h3>
      <p>
        Die Funktionen der <tt>Hlk</tt>-Erweiterung helfen bei der Realisierung
        von Heizungs- und Lüftungsreglern.
      </p>
      <table class="Tabelle_Logicnode">
        <colgroup>
          <col style="width: 175px">
          <col style="width: 125px">
          <col>
        </colgroup>
        <tr>
          <th>
            <h4>Funktion</h4>
          </th>
          <th>
            <h4>Datentyp</h4>
          </th>
          <th>
            <h4>Beschreibung</h4>
          </th>
        </tr>
        <tr>
          <td>
            <p><tt>Hlk.HeatingCurve<br />(</tt><i>TaAvg</i><tt>, </tt><i>...</i><tt>)</tt></p>
          </td>
          <td>
            <p><tt>double</tt></p>
          </td>
          <td>
            <p>
              Errechnet aus der gedämpften (zeitlich gemittelten) Außentemperatur <i>TaAvg</i>
              in °C und weiteren Parametern die benötigte Vorlauftemperatur für einen Heizkreis.
              Die Parameter passen die Heizkurve an die Gegebenheiten des Gebäudes und der
              Heizungsanlage an. Aufgrund des Umfangs findet sich die genaue Beschreibung dieser
              Funktion und ein Anwendungsbeispiel
              <a href="HeatingCurve.html">auf einer eigenen Seite</a>.
            </p>
          </td>
        </tr>
        <tr>
          <td class="group" colspan="3">
            <p>
              Viele Außen- und Raumsensoren können Temperatur (in °C) und relative Luftfeuchtigkeit
              (in %) messen. Die folgenden Funktionen errechnen daraus andere in der Lüftungs- und
              Klimatechnik wichtige Größen:
            </p>
          </td>
        </tr>
        <tr>
          <td class="group">
            <p><tt>Hlk.AbsHumidity(</tt><i>T</i><tt>, </tt><i>rf</i><tt>)</tt></p>
          </td>
          <td class="group">
            <p><tt>double</tt></p>
          </td>
          <td class="group">
            <p>
              Errechnet aus der Temperatur <i>T</i> in °C und der relativen
              Luftfeuchtigkeit <i>rf</i> in % die absolute Luftfeuchtiggkeit
              (in g/m<sup>3</sup>). Dieser Wert gibt an, wie viel Wasserdampf
              in einem Kubikmeter Luft enthalten ist.
            </p>
          </td>
        </tr>
        <tr>
          <td class="group">
            <p><tt>Hlk.DewPoint(</tt><i>T</i><tt>, </tt><i>rf</i><tt>)</tt></p>
          </td>
          <td class="group">
            <p><tt>double</tt></p>
          </td>
          <td class="group">
            <p>
              Errechnet aus der Temperatur <i>T</i> in °C und der relativen
              Luftfeuchtigkeit <i>rf</i> in % die Taupunkt-Temperatur (in °C).
              Dieser Wert gibt an, bei welcher Temperatur die relative
              Luftfeuchtigkeit 100% wäre, der Wasserdampf also gerade anfangen
              würde zu kondensieren.
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="3">
            <p>
              Da exakte Berechnungsverfahren nicht existieren, liefern beide Funktionen
              gute Näherungswerte auf der Grundlage der
              <a href="http://www.wetterochs.de/wetter/feuchte.html">Magnusformel</a>.
            </p>
            <p>
              Sie können beispielsweise dazu dienen, eine Lüftungsanlage (von der wir
              annehmen wollen, dass sie keinen Luftentfeuchter hat) bedarfsgerecht (also
              nicht unnötig) und zielorientiert (also nicht kontraproduktiv) zu steuern.
              So hat es z. B. keinen Sinn, einem Raum absolut feuchtere Außenluft
              zuzuführen, wenn Luftfeuchtigkeit und Taupunkt-Temperatur ohnehin schon
              höher sind als gewünscht.
            </p>
          </td>
        </tr>
      </table>
      <h2 id="kommentare">Kommentare</h2>
      <p>
        Die Formeln können mit Kommentaren in der Form
        <span class="box-noscroll"> <tt>/* ... */</tt> </span> dokumentiert werden.
        Darin kann anstelle von <tt>...</tt>
        nahezu beliebiger Text stehen. Solche Kommentare &ndash; auch mehrere davon
        &ndash; können am Anfang, am Ende oder an anderen Stellen der Formel stehen.
      </p>
      <h2>Beispiele</h2>
      <p>
        Das
        <a href="HeatingCurve.html#heizbeispiel">Anwendungsbeispiel "Bedarfsgeführte Heizungsregelung"</a>
        findet sich bei der
        <a href="HeatingCurve.html">Beschreibung der Funktion HeatingCurve</a>.
      </p>
      <h3 id="feiertagbeispiel">Feiertage</h3>
      <p>
        An Feiertagen und ihren Vortagen sollen bestimmte Automatisierungsfunktionen
        anders ablaufen als an normalen Werktagen. Die folgende Formel berechnet dazu
        zunächst das morgige Datum als STRING:<br />
        <span class="box-noscroll"> <tt>DateTime.Today.AddDays(1).ToString("d") /* Datum für Morgen errechnen */</tt> </span><br />
      </p>
      <p>
        Dieses dient als Parameter für eine Web-Anfrage mittels
        <a href="https://github.com/daniel-kun/Albuschat.LogicNodes/releases">Web Request</a> oder
        <a href="http://service.knx-user-forum.de/?comm=download&id=20000065">HTTP GET Request</a>.
        Der Request-Baustein wird mit folgender URL parametriert:<br />
        <span class="box-noscroll"> <tt>http://ipty.de/feiertag/api.php?do=isFeiertag&loc=BW&datum={Morgen}</tt> </span><br />
        Ein zweiter Request-Baustein verwendet fast die gleiche URL, aber ohne
        den Datumsparameter (was implizit "heute" bedeutet):
        <span class="box-noscroll"> <tt>http://ipty.de/feiertag/api.php?do=isFeiertag&loc=BW</tt> </span><br />
        In beiden steht <tt>BW</tt> für das Bundesland Baden-Württemberg; die Kürzel
        für andere Bundesländer entnimmt man der
        <a href="http://ipty.de/feiertag/">Online-Dokumentation</a>
        des Webservices.
      </p>
      <p>
        Das komplette Logikblatt sieht so aus &ndash; wieder mit beispielhaften
        Simulationsdaten:
        <img src="ExpressionCalculatorExample2.png" alt="" class="example" />
      </p>
      <p>
        Der Triggereingang löst eine neue Formelauswertung aus. Er wird an
        die Request-Bausteine nur durch gereicht (Ausgangstyp BOOL). Er sollte
        täglich kurz nach Mitternacht eine 1 erhalten. Wir nutzen, dass die
        Formelberechnung <i>alle</i> Formeln neu rechnet, sobald sich <i>ein</i>
        Eingangswert ändert: Die Datumsberechnung hat <i>gar keinen</i>
        Eingangswert, wird aber dennoch angestoßen, sobald ein Trigger
        eintrifft.
      </p>
      <h3 id="hysteresebeispiel">Verbesserter Schwellwert mit Hysterese</h3>
      <p>
        Der Gira-Baustein "Schwellwert mit Hysterese" setzt seinen Ausgang nur
        dann neu, wenn ein neuer Auslöser-Wert eintrifft. Ändern sich nur die
        Schwellwerte, so bleibt dies ohne Wirkung. Oft ist deshalb zusätzlich
        Logik mit einem Wertgenerator für den Auslöser notwendig, um das
        gewünschte Verhalten zu erreichen. Man erhält in diesen Fällen
        übersichtlichere Logikblätter mit weniger Bausteinen, wenn man eine
        Formelberechnung mit folgenden Formeln einsetzt:<br />
        Formel 1: <span class="box-noscroll"> <tt>{Auslöser:N} > {ObereSchwelle:N}</tt> </span><br />
        Formel 2: <span class="box-noscroll"> <tt>{Auslöser:N} < {UntereSchwelle:N}</tt> </span><br />
        Formel 3: <span class="box-noscroll"> <tt>_out1_ ? (bool?)true : (_out2_ ? (bool?)false : /* nichts senden */ null)</tt> </span>
      </p>
      <p>
        Alle drei Ausgänge sind vom Typ BOOL. Der dritte gibt das gewünschte
        Endergebnis aus; die ersten beiden bleiben daher unbelegt. Solange
        der Auslöser zwischen den beiden Schwellwerten liegt, ergeben die
        beiden ersten Formeln jeweils <tt>false</tt>. Formel 3 gibt in
        diesem Fall <em>nichts</em> aus.
      </p>
      <p>Hinweise:</p>
      <ul>
        <li>
          Anders als beim Gira-Baustein "Schwellwert mit Hysterese" bleibt
          der Ausgang mit dieser Formel so lange undefiniert, bis ein
          Eingangstelegramm eintrifft, dessen Wert entweder unterhalb der
          unteren oder oberhalb der oberen Schwelle liegt. Man sollte daher
          die Eingangswerte nachfolgender Bausteine geeignet vorbelegen,
          sonst werden diese möglicherweise nach einem Neustart für längere
          Zeit nicht ausgeführt.
        </li>
        <li>
          Wie beim Original-Gira-Baustein gibt es sinnvolle Ausgabewerte nur,
          wenn die Schwellwerte nicht vertauscht werden. Im einfachsten Fall
          legt man dazu direkt in der ersten Formel den oberen Schwellwert auf
          eine höhere Zahl als den unteren Schwellwert fest:<br />
          Formel 1: <span class="box-noscroll"> <tt>{Auslöser:N} > ({UntereSchwelle:N} + 2.0) /* obere Schwelle */</tt> </span><br />
          Die beiden weiteren Formeln bleiben wie oben angegeben.
        </li>
      </ul>
      <h3 id="summenzaehler">Summenzähler</h3>
      <p>
        Die folgende Formel erhöht, beginnend bei <tt>0</tt>, mit jedem
        eintreffenden Telegramm am Eingang <tt>Erhöhung</tt> den Ausgang
        um den eingehenden Wert:<br />
        <span class="box-noscroll"> <tt>{Neustart:B} ? 0 /* neu starten */ : (_previousOut1_ + {Erhöhung:I}) /* aufsummieren */</tt> </span><br />
        Aufgrund des Bedingungsoperators gilt dies jedoch nur so lange,
        wie der Eingang <tt>Neustart</tt> den Wert <tt>false</tt> hat.
        Wenn und solange <tt>Neustart</tt> den Wert <tt>true</tt> hat,
        wird jede <tt>Erhöhung</tt> verworfen und der Ausgang wird (oder
        bleibt bei) <tt>0</tt>.
      </p>
      <p>
        Die angegebene Formel erzeugt am Ausgang eine Ganzzahl (z. B.
        INTEGER). Sie lässt sich leicht so abwandeln, dass sie
        Fließkommazahlen verarbeitet und ausgibt.
      </p>
    </div>
  </section>
  <footer>
    <div id="footerHead">
      Recomedia Visu- &amp; Web-Logikbausteine &nbsp; <span style="color: #a0a0a0;">Hilfe</span>
    </div>
    <div id="footerNav">
      <img src="../icons/ExpressionCalculatorNode.png" alt="" />
      <span style="color: #a0a0a0;">&nbsp;Formelberechnung</span>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="StringFormatter.html"><img src="../icons/StringFormatterNode.png" alt="" /></a>
      &nbsp;<a href="StringFormatter.html">Textformatierer</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="XmlParser.html"><img src="../icons/XmlJsonParserNode.png" alt="" /></a>
      &nbsp;<a href="XmlParser.html">XML/JSON-Parser</a>
      <span style="float: right;">Weitere Logikbausteine sind in Planung.</span>
    </div>
  </footer>
</body>
</html>
